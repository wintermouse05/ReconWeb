
################################################################################
#                      RECONWEB                                          #
#                   SOURCE CODE DOCUMENTATION GENERATOR                    #
#        Version 2.8.0 - JS / JSX SUPPORT + SELF EXCLUDE MODE              #
################################################################################

================================================================================
                        DANH S√ÅCH FILE - 64 FILES
================================================================================

  1. .dockerignore
  2. README.md
  3. client/.dockerignore
  4. client/.env
  5. client/.env.example
  6. client/.gitignore
  7. client/README.md
  8. client/eslint.config.js
  9. client/package-lock.json
 10. client/package.json
 11. client/postcss.config.js
 12. client/public/vite.svg
 13. client/src/App.css
 14. client/src/App.jsx
 15. client/src/assets/react.svg
 16. client/src/components/FindingsList.jsx
 17. client/src/components/Layout.jsx
 18. client/src/components/ProtectedRoute.jsx
 19. client/src/components/RemediationPanel.jsx
 20. client/src/components/ScanProgress.jsx
 21. client/src/components/ScanResultAccordion.jsx
 22. client/src/components/ScanSummary.jsx
 23. client/src/components/ToolOptionForm.jsx
 24. client/src/config.js
 25. client/src/constants/tools.js
 26. client/src/context/AuthContext.jsx
 27. client/src/index.css
 28. client/src/main.jsx
 29. client/src/pages/CodeReviewPage.jsx
 30. client/src/pages/DashboardPage.jsx
 31. client/src/pages/LoginPage.jsx
 32. client/src/pages/RegisterPage.jsx
 33. client/src/pages/ScanDetailsPage.jsx
 34. client/src/pages/ScanHistoryPage.jsx
 35. client/src/pages/SubscriptionPage.jsx
 36. client/src/services/apiClient.js
 37. client/tailwind.config.js
 38. client/vite.config.js
 39. package-lock.json
 40. package.json
 41. server/.dockerignore
 42. server/.env
 43. server/.env.example
 44. server/package-lock.json
 45. server/package.json
 46. server/src/config/db.js
 47. server/src/controllers/authController.js
 48. server/src/controllers/scanController.js
 49. server/src/index.js
 50. server/src/middleware/authMiddleware.js
 51. server/src/models/CodeReview.js
 52. server/src/models/Scan.js
 53. server/src/models/User.js
 54. server/src/routes/authRoutes.js
 55. server/src/routes/codeReviewRoutes.js
 56. server/src/routes/remediationRoutes.js
 57. server/src/routes/scanRoutes.js
 58. server/src/routes/subscriptionRoutes.js
 59. server/src/services/codeReviewService.js
 60. server/src/services/pdfGenerator.js
 61. server/src/services/remediationService.js
 62. server/src/services/resultParser.js
 63. server/src/services/scanService.js
 64. server/src/services/subscriptionService.js


================================================================================
                          N·ªòI DUNG CHI TI·∫æT FILE
================================================================================

################################################################################
## FILE 1: .dockerignore
## Path: .dockerignore
################################################################################

[File t·ªìn t·∫°i ‚Äì kh√¥ng ƒë·ªçc n·ªôi dung theo c·∫•u h√¨nh]



################################################################################
## FILE 2: README.md
## Path: README.md
################################################################################

# ReconWeb - Web Vulnerability Scanning Platform

<div align="center">

![ReconWeb Logo](https://img.shields.io/badge/ReconWeb-Security%20Scanner-blue?style=for-the-badge&logo=security)

[![Node.js](https://img.shields.io/badge/Node.js-20+-green?style=flat-square&logo=node.js)](https://nodejs.org/)
[![React](https://img.shields.io/badge/React-18+-blue?style=flat-square&logo=react)](https://reactjs.org/)
[![MongoDB](https://img.shields.io/badge/MongoDB-7+-green?style=flat-square&logo=mongodb)](https://www.mongodb.com/)
[![Docker](https://img.shields.io/badge/Docker-Ready-blue?style=flat-square&logo=docker)](https://www.docker.com/)
[![License](https://img.shields.io/badge/License-MIT-yellow?style=flat-square)](LICENSE)

**ReconWeb** is a full-stack web application that automates running open-source vulnerability scanners against user-provided targets. It provides a modern UI for configuring scans, tracking progress in real-time, and generating professional reports.

[Features](#features) ‚Ä¢ [Quick Start](#quick-start) ‚Ä¢ [Installation](#installation) ‚Ä¢ [API Docs](#api-endpoints) ‚Ä¢ [Contributing](#contributing)

</div>

---

## üìã Table of Contents

- [Features](#features)
- [Supported Security Tools](#supported-security-tools)
- [Tech Stack](#tech-stack)
- [Quick Start](#quick-start)
- [Installation](#installation)
  - [Docker (Recommended)](#docker-deployment-recommended)
  - [Local Development](#local-development)
- [Configuration](#configuration)
- [API Endpoints](#api-endpoints)
- [Project Structure](#project-structure)
- [Contributing](#contributing)
- [License](#license)

---

## ‚ú® Features

### Core Features
- üîç **Automated Security Scanning** - Run multiple security tools against web targets
- üìä **Real-time Progress Tracking** - Monitor scan progress with live updates
- üìú **Scan History** - View and manage all past scans with filtering
- üìÑ **Export Reports** - Generate PDF, JSON, and TXT reports
- üéØ **Finding Extraction** - Automatic parsing and categorization of vulnerabilities
- üîê **User Authentication** - Secure JWT-based authentication

### Subscription Plans
| Feature | Free | Pro ($9.99/mo) | VIP ($29.99/mo) |
|---------|------|----------------|-----------------|
| Scans/Month | 10 | 100 | Unlimited |
| Code Reviews/Day | 3 | 20 | Unlimited |
| Basic Tools | ‚úÖ | ‚úÖ | ‚úÖ |
| Advanced Tools | ‚ùå | ‚úÖ | ‚úÖ |
| AI Code Review | ‚ùå | ‚úÖ | ‚úÖ |
| Auto Remediation | ‚ùå | ‚ùå | ‚úÖ |

### Advanced Features
- ü§ñ **Secure Code Review** - Pattern-based security analysis for 10+ languages
- üîß **Remediation Suggestions** - Rule-based fix recommendations with code examples
- üìà **Risk Scoring** - Automatic severity classification and risk assessment

---

## üõ† Supported Security Tools

| Tool | Description | Category |
|------|-------------|----------|
| **Nikto** | Web server scanner | Web Security |
| **Gobuster** | Directory/DNS brute-forcer | Enumeration |
| **Nuclei** | Template-based vulnerability scanner | Vulnerability |
| **SQLMap** | SQL injection detection | Database |
| **XSStrike** | XSS detection suite | Web Security |
| **WPScan** | WordPress vulnerability scanner | CMS Security |

---

## üèó Tech Stack

### Backend
- **Runtime**: Node.js 20+
- **Framework**: Express.js 5
- **Database**: MongoDB 7+
- **Authentication**: JWT + bcrypt

### Frontend
- **Framework**: React 18 + Vite
- **UI Library**: React Bootstrap
- **Styling**: Tailwind CSS
- **HTTP Client**: Fetch API

### DevOps
- **Containerization**: Docker + Docker Compose
- **Web Server**: Nginx (production)
- **Process Manager**: Node.js native

---

## üöÄ Quick Start

### Using Docker (Fastest)

```bash
# Clone the repository
git clone https://github.com/wintermouse05/ReconWeb.git
cd ReconWeb

# Start all services
docker compose up --build

# Access the application
# Frontend: http://localhost:3000
# API: http://localhost:5000/api
```

### Using npm

```bash
# Clone and install
git clone https://github.com/wintermouse05/ReconWeb.git
cd ReconWeb
npm install
npm install --prefix server
npm install --prefix client

# Setup environment
cp server/.env.example server/.env
# Edit server/.env with your settings

# Start development servers
npm run dev
```

---

## üì¶ Installation

### Prerequisites

- **Node.js** 20.x or higher
- **MongoDB** 7.x or higher
- **Docker** & **Docker Compose** (for containerized deployment)
- **Security Tools** (for local development):
  - Nikto, Gobuster, SQLMap, WPScan, XSStrike, Nuclei

### Docker Deployment (Recommended)

1. **Clone the repository**
   ```bash
   git clone https://github.com/wintermouse05/ReconWeb.git
   cd ReconWeb
   ```

2. **Configure environment** (optional)
   ```bash
   # Create .env file for docker-compose
   echo "JWT_SECRET=$(openssl rand -base64 32)" > .env
   ```

3. **Build and start containers**
   ```bash
   docker compose up --build -d
   ```

4. **Verify deployment**
   ```bash
   # Check container status
   docker compose ps
   
   # View logs
   docker compose logs -f
   ```

5. **Access the application**
   - **Frontend**: http://localhost:3000
   - **API**: http://localhost:5000/api
   - **MongoDB**: mongodb://localhost:27017

### Local Development

1. **Install system dependencies** (Ubuntu/Debian)
   ```bash
   # Security tools
   sudo apt update
   sudo apt install -y nikto gobuster sqlmap wpscan
   
   # Install Go for Nuclei
   sudo apt install -y golang-go
   go install -v github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest
   echo 'export PATH=$PATH:$HOME/go/bin' >> ~/.bashrc
   source ~/.bashrc
   
   # Install XSStrike
   sudo pip3 install xsstrike --break-system-packages
   # Or from source:
   git clone https://github.com/s0md3v/XSStrike.git /opt/XSStrike
   sudo ln -sf /opt/XSStrike/xsstrike.py /usr/local/bin/xsstrike
   ```

2. **Install Node.js dependencies**
   ```bash
   npm install
   npm install --prefix server
   npm install --prefix client
   ```

3. **Configure environment**
   ```bash
   cp server/.env.example server/.env
   ```
   
   Edit `server/.env`:
   ```env
   PORT=5000
   MONGODB_URI=mongodb://localhost:27017/reconweb
   JWT_SECRET=your-super-secret-key-min-32-characters
   CLIENT_ORIGIN=http://localhost:5173
   ```

4. **Start MongoDB**
   ```bash
   # Using Docker
   docker run -d --name mongodb -p 27017:27017 mongo:7
   
   # Or using system service
   sudo systemctl start mongod
   ```

5. **Start development servers**
   ```bash
   npm run dev
   ```

6. **Access the application**
   - **Frontend**: http://localhost:5173
   - **API**: http://localhost:5000/api

---

## ‚öôÔ∏è Configuration

### Server Environment Variables

| Variable | Description | Default |
|----------|-------------|---------|
| `PORT` | Server port | `5000` |
| `MONGODB_URI` | MongoDB connection string | `mongodb://localhost:27017/reconweb` |
| `JWT_SECRET` | Secret key for JWT tokens | Required |
| `CLIENT_ORIGIN` | Allowed CORS origins (comma-separated) | `http://localhost:5173` |
| `NODE_ENV` | Environment mode | `development` |

### Client Environment Variables

| Variable | Description | Default |
|----------|-------------|---------|
| `VITE_API_BASE_URL` | Backend API URL | `http://localhost:5000/api` |

---

## üì° API Endpoints

### Authentication
| Method | Endpoint | Description |
|--------|----------|-------------|
| POST | `/api/auth/register` | Register new user |
| POST | `/api/auth/login` | Login user |
| GET | `/api/auth/me` | Get current user info |

### Scans
| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/api/scans/tools/installed` | Get installed tools |
| POST | `/api/scans` | Create new scan |
| GET | `/api/scans` | List all scans |
| GET | `/api/scans/:id` | Get scan details |
| GET | `/api/scans/:id/export` | Export scan (json/txt/pdf) |

### Subscription
| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/api/subscription/plans` | Get all plans |
| GET | `/api/subscription/status` | Get subscription status |
| POST | `/api/subscription/upgrade` | Upgrade plan |

### Code Review
| Method | Endpoint | Description |
|--------|----------|-------------|
| POST | `/api/code-review/review` | Submit code for review |
| GET | `/api/code-review/history` | Get review history |
| GET | `/api/code-review/:id` | Get specific review |
| DELETE | `/api/code-review/:id` | Delete review |

### Remediation
| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/api/remediation/scan/:id` | Get AI remediation (VIP) |
| GET | `/api/remediation/basic/:id` | Get basic remediation |
| GET | `/api/remediation/tips/:severity` | Get quick tips |

---

## üìÅ Project Structure

```
ReconWeb/
‚îú‚îÄ‚îÄ client/                    # React Frontend
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/        # Reusable UI components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/             # Page components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ context/           # React context providers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/          # API client
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ constants/         # Tool definitions
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ App.jsx            # Root component
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îú‚îÄ‚îÄ nginx.conf
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îÇ
‚îú‚îÄ‚îÄ server/                    # Express Backend
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config/            # Database config
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ controllers/       # Request handlers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ middleware/        # Auth middleware
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/            # Mongoose schemas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes/            # API routes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/          # Business logic
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.js           # Entry point
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îú‚îÄ‚îÄ .env.example
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îÇ
‚îú‚îÄ‚îÄ docker-compose.yml         # Container orchestration
‚îú‚îÄ‚îÄ package.json               # Root package (scripts)
‚îî‚îÄ‚îÄ README.md
```

---

## ü§ù Contributing

Contributions are welcome! Please follow these steps:

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

### Development Guidelines
- Follow existing code style
- Write meaningful commit messages
- Add tests for new features
- Update documentation as needed

---

## üìÑ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

---

## ‚ö†Ô∏è Disclaimer

This tool is intended for **authorized security testing only**. Always obtain proper authorization before scanning any systems you do not own. The developers are not responsible for any misuse of this software.

---

## üôè Acknowledgments

- [Nikto](https://github.com/sullo/nikto) - Web server scanner
- [Gobuster](https://github.com/OJ/gobuster) - Directory brute-forcer
- [Nuclei](https://github.com/projectdiscovery/nuclei) - Vulnerability scanner
- [SQLMap](https://github.com/sqlmapproject/sqlmap) - SQL injection tool
- [XSStrike](https://github.com/s0md3v/XSStrike) - XSS detection
- [WPScan](https://github.com/wpscanteam/wpscan) - WordPress scanner

---

<div align="center">

**Made with ‚ù§Ô∏è for the security community**

[‚¨Ü Back to Top](#reconweb---web-vulnerability-scanning-platform)

</div>




################################################################################
## FILE 3: .dockerignore
## Path: client/.dockerignore
################################################################################

[File t·ªìn t·∫°i ‚Äì kh√¥ng ƒë·ªçc n·ªôi dung theo c·∫•u h√¨nh]



################################################################################
## FILE 4: .env
## Path: client/.env
################################################################################

VITE_API_BASE_URL=http://localhost:5000/api




################################################################################
## FILE 5: .env.example
## Path: client/.env.example
################################################################################

VITE_API_BASE_URL=http://localhost:5000/api




################################################################################
## FILE 6: .gitignore
## Path: client/.gitignore
################################################################################

[File t·ªìn t·∫°i ‚Äì kh√¥ng ƒë·ªçc n·ªôi dung theo c·∫•u h√¨nh]



################################################################################
## FILE 7: README.md
## Path: client/README.md
################################################################################

# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.




################################################################################
## FILE 8: eslint.config.js
## Path: client/eslint.config.js
################################################################################

import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])




################################################################################
## FILE 9: package-lock.json
## Path: client/package-lock.json
################################################################################

[File t·ªìn t·∫°i ‚Äì kh√¥ng ƒë·ªçc n·ªôi dung theo c·∫•u h√¨nh]



################################################################################
## FILE 10: package.json
## Path: client/package.json
################################################################################

[File t·ªìn t·∫°i ‚Äì kh√¥ng ƒë·ªçc n·ªôi dung theo c·∫•u h√¨nh]



################################################################################
## FILE 11: postcss.config.js
## Path: client/postcss.config.js
################################################################################

export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}




################################################################################
## FILE 12: vite.svg
## Path: client/public/vite.svg
################################################################################

[File binary / asset ‚Äì kh√¥ng hi·ªÉn th·ªã n·ªôi dung]



################################################################################
## FILE 13: App.css
## Path: client/src/App.css
################################################################################

#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}




################################################################################
## FILE 14: App.jsx
## Path: client/src/App.jsx
################################################################################

import { BrowserRouter, Navigate, Route, Routes } from 'react-router-dom';
import { AuthProvider } from './context/AuthContext';
import ProtectedRoute from './components/ProtectedRoute';
import Layout from './components/Layout';
import LoginPage from './pages/LoginPage';
import RegisterPage from './pages/RegisterPage';
import DashboardPage from './pages/DashboardPage';
import ScanHistoryPage from './pages/ScanHistoryPage';
import ScanDetailsPage from './pages/ScanDetailsPage';
import SubscriptionPage from './pages/SubscriptionPage';
import CodeReviewPage from './pages/CodeReviewPage';

const App = () => (
  <AuthProvider>
    <BrowserRouter>
      <Routes>
        <Route path="/login" element={<LoginPage />} />
        <Route path="/register" element={<RegisterPage />} />
        <Route
          element={
            <ProtectedRoute>
              <Layout />
            </ProtectedRoute>
          }
        >
          <Route index element={<DashboardPage />} />
          <Route path="history" element={<ScanHistoryPage />} />
          <Route path="scans/:id" element={<ScanDetailsPage />} />
          <Route path="subscription" element={<SubscriptionPage />} />
          <Route path="code-review" element={<CodeReviewPage />} />
        </Route>
        <Route path="*" element={<Navigate to="/" replace />} />
      </Routes>
    </BrowserRouter>
  </AuthProvider>
);

export default App;




################################################################################
## FILE 15: react.svg
## Path: client/src/assets/react.svg
################################################################################

[File binary / asset ‚Äì kh√¥ng hi·ªÉn th·ªã n·ªôi dung]



################################################################################
## FILE 16: FindingsList.jsx
## Path: client/src/components/FindingsList.jsx
################################################################################

import { Badge, Card, ListGroup } from 'react-bootstrap';

const FindingsList = ({ findings }) => {
  if (!findings || findings.length === 0) {
    return null;
  }

  const getSeverityVariant = (severity) => {
    switch (severity) {
      case 'critical':
        return 'danger';
      case 'high':
        return 'warning';
      case 'medium':
        return 'info';
      case 'low':
        return 'primary';
      case 'info':
        return 'secondary';
      default:
        return 'light';
    }
  };

  const getTypeIcon = (type) => {
    switch (type) {
      case 'vulnerability':
        return 'üî¥';
      case 'directory':
        return 'üìÅ';
      case 'information':
        return '‚ÑπÔ∏è';
      default:
        return '‚Ä¢';
    }
  };

  return (
    <Card className="mb-3">
      <Card.Header className="bg-light">
        <strong>Chi ti·∫øt ph√°t hi·ªán ({findings.length})</strong>
      </Card.Header>
      <ListGroup variant="flush" style={{ maxHeight: '400px', overflowY: 'auto' }}>
        {findings.map((finding, index) => (
          <ListGroup.Item key={index} className="d-flex justify-content-between align-items-start">
            <div className="flex-grow-1">
              <div className="d-flex align-items-center mb-1">
                <span className="me-2">{getTypeIcon(finding.type)}</span>
                <Badge bg={getSeverityVariant(finding.severity)} className="me-2">
                  {finding.severity.toUpperCase()}
                </Badge>
                <small className="text-muted">[{finding.tool}]</small>
              </div>
              <div className="text-break">{finding.description}</div>
              {finding.path && (
                <small className="text-muted d-block mt-1">Path: {finding.path}</small>
              )}
              {finding.templateId && (
                <small className="text-muted d-block mt-1">Template: {finding.templateId}</small>
              )}
            </div>
          </ListGroup.Item>
        ))}
      </ListGroup>
    </Card>
  );
};

export default FindingsList;




################################################################################
## FILE 17: Layout.jsx
## Path: client/src/components/Layout.jsx
################################################################################

import { Container, Navbar, Nav, NavDropdown, Badge } from 'react-bootstrap';
import { Link, Outlet, useNavigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';
import { FaShieldAlt, FaHistory, FaTachometerAlt, FaCode, FaCrown } from 'react-icons/fa';

const Layout = () => {
  const { user, logout } = useAuth();
  const navigate = useNavigate();

  const handleLogout = () => {
    logout();
    navigate('/login', { replace: true });
  };

  return (
    <div className="min-vh-100 d-flex flex-column bg-body-tertiary">
      <Navbar bg="dark" variant="dark" expand="lg" className="shadow-sm">
        <Container>
          <Navbar.Brand as={Link} to="/">
            <FaShieldAlt className="me-2" />
            ReconWeb
          </Navbar.Brand>
          <Navbar.Toggle aria-controls="main-navbar" />
          <Navbar.Collapse id="main-navbar">
            <Nav className="me-auto">
              <Nav.Link as={Link} to="/">
                <FaTachometerAlt className="me-1" /> Dashboard
              </Nav.Link>
              <Nav.Link as={Link} to="/history">
                <FaHistory className="me-1" /> History
              </Nav.Link>
              <Nav.Link as={Link} to="/code-review">
                <FaCode className="me-1" /> Code Review
              </Nav.Link>
            </Nav>
            <Nav className="ms-auto">
              <Nav.Link as={Link} to="/subscription" className="me-2">
                <FaCrown className="text-warning me-1" /> Plans
              </Nav.Link>
              <NavDropdown title={user?.name || 'Account'} align="end">
                <NavDropdown.Item disabled>Email: {user?.email}</NavDropdown.Item>
                <NavDropdown.Divider />
                <NavDropdown.Item as={Link} to="/subscription">
                  <FaCrown className="me-2 text-warning" /> Subscription
                </NavDropdown.Item>
                <NavDropdown.Divider />
                <NavDropdown.Item onClick={handleLogout}>Log out</NavDropdown.Item>
              </NavDropdown>
            </Nav>
          </Navbar.Collapse>
        </Container>
      </Navbar>
      <main className="flex-grow-1 py-4">
        <Container>
          <Outlet />
        </Container>
      </main>
      <footer className="bg-dark text-white py-3 text-center">
        <small>&copy; {new Date().getFullYear()} ReconWeb Security Automation</small>
      </footer>
    </div>
  );
};

export default Layout;




################################################################################
## FILE 18: ProtectedRoute.jsx
## Path: client/src/components/ProtectedRoute.jsx
################################################################################

import { Navigate, useLocation } from 'react-router-dom';
import { Spinner } from 'react-bootstrap';
import { useAuth } from '../context/AuthContext';

const ProtectedRoute = ({ children }) => {
  const { isAuthenticated, loading } = useAuth();
  const location = useLocation();

  if (loading) {
    return (
      <div className="min-h-screen d-flex align-items-center justify-content-center bg-body-secondary">
        <div className="text-center">
          <Spinner animation="border" role="status" />
          <p className="mt-3 mb-0">Loading...</p>
        </div>
      </div>
    );
  }

  if (!isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return children;
};

export default ProtectedRoute;




################################################################################
## FILE 19: RemediationPanel.jsx
## Path: client/src/components/RemediationPanel.jsx
################################################################################

import { useState, useEffect } from 'react';
import { Card, Button, Badge, Alert, Spinner, Accordion, ListGroup, OverlayTrigger, Tooltip } from 'react-bootstrap';
import { apiRequest } from '../services/apiClient';
import { useAuth } from '../context/AuthContext';
import { FaMagic, FaLightbulb, FaClipboardList, FaShieldAlt, FaLock, FaCrown, FaRocket, FaExternalLinkAlt } from 'react-icons/fa';

const RemediationPanel = ({ scanId, findings, targetUrl }) => {
  const { user, token } = useAuth();
  const [remediation, setRemediation] = useState(null);
  const [basicRemediation, setBasicRemediation] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [isVip, setIsVip] = useState(false);

  useEffect(() => {
    checkVipStatus();
    fetchBasicRemediation();
  }, [scanId]);

  const checkVipStatus = async () => {
    try {
      const status = await apiRequest('/subscription/status', { token });
      setIsVip(status.plan?.id === 'vip' && status.status === 'active');
    } catch (err) {
      console.error('Error checking VIP status:', err);
    }
  };

  const fetchBasicRemediation = async () => {
    try {
      const res = await apiRequest(`/remediation/basic/${scanId}`, { token });
      setBasicRemediation(res);
    } catch (err) {
      console.error('Error fetching basic remediation:', err);
    }
  };

  const fetchAIRemediation = async () => {
    try {
      setLoading(true);
      setError('');
      const res = await apiRequest(`/remediation/scan/${scanId}`, { token });
      setRemediation(res);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  const getSeverityColor = (severity) => {
    const colors = {
      critical: 'danger',
      high: 'warning',
      medium: 'info',
      low: 'secondary'
    };
    return colors[severity] || 'secondary';
  };

  const getEffortBadge = (effort) => {
    const colors = { low: 'success', medium: 'warning', high: 'danger' };
    return <Badge bg={colors[effort] || 'secondary'}>{effort} effort</Badge>;
  };

  if (!findings || findings.length === 0) {
    return (
      <Alert variant="success">
        <FaShieldAlt className="me-2" />
        No vulnerabilities found. No remediation needed!
      </Alert>
    );
  }

  return (
    <Card className="mb-4">
      <Card.Header className="d-flex justify-content-between align-items-center">
        <h5 className="mb-0">
          <FaMagic className="me-2" />
          Remediation Suggestions
        </h5>
        {isVip ? (
          <Badge bg="warning" text="dark">
            <FaCrown className="me-1" /> VIP Access
          </Badge>
        ) : (
          <Badge bg="secondary">Basic</Badge>
        )}
      </Card.Header>
      <Card.Body>
        {error && (
          <Alert variant="danger" dismissible onClose={() => setError('')}>
            {error}
          </Alert>
        )}

        {/* AI-Powered Remediation (VIP) */}
        {isVip && (
          <div className="mb-4">
            {!remediation ? (
              <div className="text-center py-3">
                <p className="text-muted mb-3">
                  Get detailed, AI-powered remediation suggestions with code examples and step-by-step guidance.
                </p>
                <Button variant="warning" onClick={fetchAIRemediation} disabled={loading}>
                  {loading ? (
                    <>
                      <Spinner animation="border" size="sm" className="me-2" />
                      Generating...
                    </>
                  ) : (
                    <>
                      <FaRocket className="me-2" />
                      Generate AI Remediation
                    </>
                  )}
                </Button>
              </div>
            ) : (
              <>
                {/* Summary */}
                <Alert variant="info">
                  <strong>Executive Summary:</strong> {remediation.summary}
                </Alert>

                {/* Quick Wins */}
                {remediation.quickWins && remediation.quickWins.length > 0 && (
                  <Card className="mb-3 border-success">
                    <Card.Header className="bg-success text-white">
                      <FaLightbulb className="me-2" />
                      Quick Wins
                    </Card.Header>
                    <ListGroup variant="flush">
                      {remediation.quickWins.map((win, idx) => (
                        <ListGroup.Item key={idx}>‚úì {win}</ListGroup.Item>
                      ))}
                    </ListGroup>
                  </Card>
                )}

                {/* Prioritized Actions */}
                {remediation.prioritizedActions && remediation.prioritizedActions.length > 0 && (
                  <Accordion className="mb-3">
                    {remediation.prioritizedActions.map((action, idx) => (
                      <Accordion.Item key={idx} eventKey={idx.toString()}>
                        <Accordion.Header>
                          <Badge bg={getSeverityColor(action.severity)} className="me-2">
                            #{action.priority}
                          </Badge>
                          {action.title}
                          <span className="ms-2">{getEffortBadge(action.effort)}</span>
                        </Accordion.Header>
                        <Accordion.Body>
                          <p><strong>Related Finding:</strong> {action.finding}</p>
                          <p>{action.description}</p>
                          
                          {action.steps && (
                            <>
                              <strong>Steps:</strong>
                              <ol>
                                {action.steps.map((step, sIdx) => (
                                  <li key={sIdx}>{step}</li>
                                ))}
                              </ol>
                            </>
                          )}

                          {action.codeExample && (
                            <div className="mt-3">
                              <strong>Code Example:</strong>
                              <pre className="bg-light p-3 rounded mt-2">
                                <code>{action.codeExample}</code>
                              </pre>
                            </div>
                          )}

                          {action.resources && action.resources.length > 0 && (
                            <div className="mt-3">
                              <strong>Resources:</strong>
                              <ul>
                                {action.resources.map((resource, rIdx) => (
                                  <li key={rIdx}>
                                    <a href={resource} target="_blank" rel="noopener noreferrer">
                                      {resource} <FaExternalLinkAlt size={10} />
                                    </a>
                                  </li>
                                ))}
                              </ul>
                            </div>
                          )}
                        </Accordion.Body>
                      </Accordion.Item>
                    ))}
                  </Accordion>
                )}

                {/* Long-term Recommendations */}
                {remediation.longTermRecommendations && remediation.longTermRecommendations.length > 0 && (
                  <Card className="mb-3">
                    <Card.Header>
                      <FaClipboardList className="me-2" />
                      Long-term Recommendations
                    </Card.Header>
                    <ListGroup variant="flush">
                      {remediation.longTermRecommendations.map((rec, idx) => (
                        <ListGroup.Item key={idx}>{rec}</ListGroup.Item>
                      ))}
                    </ListGroup>
                  </Card>
                )}

                {/* Compliance Notes */}
                {remediation.complianceNotes && (
                  <Card>
                    <Card.Header>
                      <FaLock className="me-2" />
                      Compliance Notes
                    </Card.Header>
                    <Card.Body>
                      {remediation.complianceNotes.owasp && (
                        <p><strong>OWASP:</strong> {remediation.complianceNotes.owasp}</p>
                      )}
                      {remediation.complianceNotes.pciDss && (
                        <p><strong>PCI-DSS:</strong> {remediation.complianceNotes.pciDss}</p>
                      )}
                      {remediation.complianceNotes.gdpr && (
                        <p><strong>GDPR:</strong> {remediation.complianceNotes.gdpr}</p>
                      )}
                    </Card.Body>
                  </Card>
                )}
              </>
            )}
          </div>
        )}

        {/* Basic Remediation (All Plans) */}
        {basicRemediation && basicRemediation.remediations && (
          <div>
            {!isVip && (
              <Alert variant="info" className="mb-3">
                <FaCrown className="me-2 text-warning" />
                Upgrade to VIP for detailed, AI-powered remediation with code examples.
                <Button variant="link" href="/subscription" className="p-0 ms-2">
                  Upgrade Now
                </Button>
              </Alert>
            )}

            <h6 className="mb-3">Basic Remediation Guidance</h6>
            <Accordion>
              {basicRemediation.remediations.map((item, idx) => (
                <Accordion.Item key={idx} eventKey={idx.toString()}>
                  <Accordion.Header>
                    <Badge bg={getSeverityColor(item.severity)} className="me-2">
                      {item.severity}
                    </Badge>
                    {item.finding}
                  </Accordion.Header>
                  <Accordion.Body>
                    <p><strong>{item.guidance?.title}:</strong> {item.guidance?.description}</p>
                    
                    <strong>Steps:</strong>
                    <ol>
                      {item.guidance?.steps?.map((step, sIdx) => (
                        <li key={sIdx}>{step}</li>
                      ))}
                    </ol>

                    {item.quickTips && (
                      <>
                        <strong>Quick Tips:</strong>
                        <ul>
                          {item.quickTips.map((tip, tIdx) => (
                            <li key={tIdx}>{tip}</li>
                          ))}
                        </ul>
                      </>
                    )}
                  </Accordion.Body>
                </Accordion.Item>
              ))}
            </Accordion>
          </div>
        )}
      </Card.Body>
    </Card>
  );
};

export default RemediationPanel;




################################################################################
## FILE 20: ScanProgress.jsx
## Path: client/src/components/ScanProgress.jsx
################################################################################

import { useEffect, useState } from 'react';
import { Alert, Badge, Card, ListGroup, ProgressBar, Spinner } from 'react-bootstrap';
import { TOOL_DEFINITIONS } from '../constants/tools';

const ScanProgress = ({ scanId, onComplete, request }) => {
  const [scan, setScan] = useState(null);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (!scanId) return;

    const pollInterval = setInterval(async () => {
      try {
        const response = await request(`/scans/${scanId}`);
        setScan(response.scan);

        // N·∫øu scan ho√†n t·∫•t ho·∫∑c failed, d·ª´ng polling
        if (response.scan.status === 'completed' || response.scan.status === 'failed') {
          clearInterval(pollInterval);
          if (onComplete) {
            onComplete(response.scan);
          }
        }
      } catch (err) {
        setError(err.message);
        clearInterval(pollInterval);
      }
    }, 2000); // Poll m·ªói 2 gi√¢y

    return () => clearInterval(pollInterval);
  }, [scanId, request, onComplete]);

  if (error) {
    return <Alert variant="danger">Error: {error}</Alert>;
  }

  if (!scan) {
    return (
      <div className="text-center py-4">
        <Spinner animation="border" />
        <p className="mt-2">Initializing scan...</p>
      </div>
    );
  }

  const getStatusVariant = (status) => {
    switch (status) {
      case 'completed':
        return 'success';
      case 'failed':
        return 'danger';
      case 'running':
        return 'primary';
      default:
        return 'secondary';
    }
  };

  const getStatusIcon = (status) => {
    switch (status) {
      case 'completed':
        return '‚úì';
      case 'failed':
        return '‚úó';
      case 'running':
        return '‚ü≥';
      case 'pending':
        return '‚óã';
      default:
        return '‚Ä¢';
    }
  };

  return (
    <Card className="shadow-sm">
      <Card.Header className="bg-light">
        <div className="d-flex justify-content-between align-items-center">
          <h5 className="mb-0">Scan Progress</h5>
          <Badge bg={getStatusVariant(scan.status)}>
            {scan.status.toUpperCase()}
          </Badge>
        </div>
      </Card.Header>
      <Card.Body>
        <div className="mb-3">
          <div className="d-flex justify-content-between mb-2">
            <span>Overall Progress</span>
            <strong>{scan.progress || 0}%</strong>
          </div>
          <ProgressBar 
            now={scan.progress || 0} 
            variant={getStatusVariant(scan.status)}
            striped={scan.status === 'running'}
            animated={scan.status === 'running'}
          />
        </div>

        <div className="mb-2">
          <strong>Target:</strong> {scan.targetUrl}
        </div>

        <div>
          <strong>Tools Status:</strong>
          <ListGroup variant="flush" className="mt-2">
            {scan.results && scan.results.map((result, index) => (
              <ListGroup.Item key={index} className="d-flex justify-content-between align-items-center px-0">
                <div className="d-flex align-items-center">
                  <span className="me-2" style={{ fontSize: '1.2em' }}>
                    {getStatusIcon(result.status)}
                  </span>
                  <span>
                    {TOOL_DEFINITIONS[result.tool]?.label || result.tool}
                  </span>
                </div>
                <div className="d-flex align-items-center gap-2">
                  {result.findings && result.findings.length > 0 && (
                    <Badge bg="danger" pill>
                      {result.findings.length} findings
                    </Badge>
                  )}
                  <Badge bg={getStatusVariant(result.status)}>
                    {result.status}
                  </Badge>
                  {result.status === 'running' && (
                    <Spinner animation="border" size="sm" />
                  )}
                </div>
              </ListGroup.Item>
            ))}
          </ListGroup>
        </div>
      </Card.Body>
    </Card>
  );
};

export default ScanProgress;




################################################################################
## FILE 21: ScanResultAccordion.jsx
## Path: client/src/components/ScanResultAccordion.jsx
################################################################################

import { Accordion, Badge } from 'react-bootstrap';
import { TOOL_DEFINITIONS } from '../constants/tools';
import FindingsList from './FindingsList';

const ScanResultAccordion = ({ results }) => {
  if (!results || !results.length) {
    return null;
  }

  return (
    <Accordion defaultActiveKey="0">
      {results.map((result, index) => {
        const toolLabel = TOOL_DEFINITIONS[result.tool]?.label || result.tool;
        const isSuccess = result.status === 'completed';
        const findingsCount = result.findings?.length || 0;

        return (
          <Accordion.Item eventKey={String(index)} key={`${result.tool}-${index}`}>
            <Accordion.Header>
              <div className="d-flex justify-content-between w-100 align-items-center">
                <span>
                  {toolLabel}
                  {findingsCount > 0 && (
                    <Badge bg="danger" className="ms-2">
                      {findingsCount} ph√°t hi·ªán
                    </Badge>
                  )}
                </span>
                <Badge bg={isSuccess ? 'success' : 'danger'}>{result.status}</Badge>
              </div>
            </Accordion.Header>
            <Accordion.Body>
              {result.findings && result.findings.length > 0 && (
                <FindingsList findings={result.findings} />
              )}
              
              <div className="mb-3">
                <strong>Options</strong>
                <pre className="bg-body-secondary p-2 rounded-2" style={{ whiteSpace: 'pre-wrap' }}>
                  {JSON.stringify(result.options || {}, null, 2)}
                </pre>
              </div>
              <div className="mb-3">
                <strong>Raw Output</strong>
                <pre className="bg-dark text-white p-2 rounded-2 overflow-auto" style={{ maxHeight: '240px' }}>
                  {result.output || 'No output recorded.'}
                </pre>
              </div>
              {result.error ? (
                <div>
                  <strong>Error</strong>
                  <pre className="bg-danger-subtle text-danger p-2 rounded-2" style={{ whiteSpace: 'pre-wrap' }}>
                    {result.error}
                  </pre>
                </div>
              ) : null}
            </Accordion.Body>
          </Accordion.Item>
        );
      })}
    </Accordion>
  );
};

export default ScanResultAccordion;




################################################################################
## FILE 22: ScanSummary.jsx
## Path: client/src/components/ScanSummary.jsx
################################################################################

import { Alert, Badge, Card, ProgressBar } from 'react-bootstrap';
import { ExclamationTriangleFill, ShieldFillCheck, InfoCircleFill } from 'react-bootstrap-icons';

const ScanSummary = ({ summary }) => {
  if (!summary) {
    return null;
  }

  const getRiskColor = (riskLevel) => {
    switch (riskLevel) {
      case 'critical':
        return 'danger';
      case 'high':
        return 'warning';
      case 'medium':
        return 'info';
      case 'low':
        return 'primary';
      case 'safe':
      case 'info':
        return 'success';
      default:
        return 'secondary';
    }
  };

  const getRiskIcon = (riskLevel) => {
    switch (riskLevel) {
      case 'critical':
      case 'high':
      case 'medium':
        return <ExclamationTriangleFill className="me-2" />;
      case 'safe':
        return <ShieldFillCheck className="me-2" />;
      default:
        return <InfoCircleFill className="me-2" />;
    }
  };

  const getRiskMessage = (riskLevel) => {
    switch (riskLevel) {
      case 'critical':
        return 'Trang web c√≥ l·ªó h·ªïng nghi√™m tr·ªçng c·∫ßn kh·∫Øc ph·ª•c ngay l·∫≠p t·ª©c!';
      case 'high':
        return 'Ph√°t hi·ªán c√°c l·ªó h·ªïng m·ª©c ƒë·ªô cao, c·∫ßn x·ª≠ l√Ω s·ªõm.';
      case 'medium':
        return 'C√≥ m·ªôt s·ªë v·∫•n ƒë·ªÅ b·∫£o m·∫≠t c·∫ßn ƒë∆∞·ª£c xem x√©t.';
      case 'low':
        return 'Ph√°t hi·ªán c√°c v·∫•n ƒë·ªÅ nh·ªè, n√™n c·∫£i thi·ªán.';
      case 'safe':
        return 'Kh√¥ng ph√°t hi·ªán l·ªó h·ªïng nghi√™m tr·ªçng.';
      case 'info':
        return 'Scan ho√†n t·∫•t, ch·ªâ c√≥ th√¥ng tin t·ªïng quan.';
      default:
        return 'K·∫øt qu·∫£ scan ƒë√£ s·∫µn s√†ng.';
    }
  };

  const { riskLevel, riskScore, counts, vulnerabilities, directories, information } = summary;
  const color = getRiskColor(riskLevel);

  return (
    <Card className="mb-4 shadow-sm">
      <Card.Header className={`bg-${color} text-white`}>
        <h5 className="mb-0">
          {getRiskIcon(riskLevel)}
          T√≥m t·∫Øt k·∫øt qu·∫£ scan
        </h5>
      </Card.Header>
      <Card.Body>
        <Alert variant={color} className="mb-3">
          <strong>{getRiskMessage(riskLevel)}</strong>
        </Alert>

        <div className="mb-3">
          <div className="d-flex justify-content-between mb-2">
            <span>Risk Score</span>
            <strong>{riskScore}/100</strong>
          </div>
          <ProgressBar 
            now={riskScore} 
            variant={color} 
            label={`${riskScore}%`}
          />
        </div>

        <div className="row text-center mb-3">
          <div className="col">
            <div className="border rounded p-3">
              <h3 className="mb-1">{counts.total || 0}</h3>
              <small className="text-muted">T·ªïng ph√°t hi·ªán</small>
            </div>
          </div>
          <div className="col">
            <div className="border rounded p-3">
              <h3 className="mb-1 text-danger">{vulnerabilities || 0}</h3>
              <small className="text-muted">L·ªó h·ªïng</small>
            </div>
          </div>
          <div className="col">
            <div className="border rounded p-3">
              <h3 className="mb-1 text-primary">{directories || 0}</h3>
              <small className="text-muted">Th∆∞ m·ª•c</small>
            </div>
          </div>
        </div>

        <div>
          <h6 className="mb-3">Ph√¢n lo·∫°i theo m·ª©c ƒë·ªô nghi√™m tr·ªçng:</h6>
          <div className="d-flex flex-wrap gap-2">
            {counts.critical > 0 && (
              <Badge bg="danger" className="px-3 py-2">
                Critical: {counts.critical}
              </Badge>
            )}
            {counts.high > 0 && (
              <Badge bg="warning" className="px-3 py-2">
                High: {counts.high}
              </Badge>
            )}
            {counts.medium > 0 && (
              <Badge bg="info" className="px-3 py-2">
                Medium: {counts.medium}
              </Badge>
            )}
            {counts.low > 0 && (
              <Badge bg="primary" className="px-3 py-2">
                Low: {counts.low}
              </Badge>
            )}
            {counts.info > 0 && (
              <Badge bg="secondary" className="px-3 py-2">
                Info: {counts.info}
              </Badge>
            )}
            {counts.total === 0 && (
              <Badge bg="success" className="px-3 py-2">
                Kh√¥ng c√≥ ph√°t hi·ªán
              </Badge>
            )}
          </div>
        </div>
      </Card.Body>
    </Card>
  );
};

export default ScanSummary;




################################################################################
## FILE 23: ToolOptionForm.jsx
## Path: client/src/components/ToolOptionForm.jsx
################################################################################

import { Col, Form, Row } from 'react-bootstrap';
import { TOOL_DEFINITIONS } from '../constants/tools';

const ToolOptionForm = ({ toolKey, values, onChange }) => {
  const tool = TOOL_DEFINITIONS[toolKey];

  if (!tool) {
    return null;
  }

  const handleChange = (name, type) => (event) => {
    let nextValue;
    if (type === 'checkbox') {
      nextValue = event.target.checked;
    } else if (type === 'number') {
      nextValue = event.target.value;
    } else {
      nextValue = event.target.value;
    }

    onChange(toolKey, name, nextValue);
  };

  return (
    <div className="border rounded-3 p-3 mb-3 bg-white shadow-sm">
      <h5 className="mb-3">{tool.label} Options</h5>
      <Row className="g-3">
        {tool.options.map((option) => {
          const { name, type = 'text' } = option;
          const value = values?.[name] ?? option.defaultValue ?? (type === 'checkbox' ? false : '');

          return (
            <Col xs={12} md={type === 'textarea' ? 12 : 6} key={name}>
              {type === 'checkbox' ? (
                <div>
                  <Form.Check
                    type="switch"
                    id={`${toolKey}-${name}`}
                    label={option.label}
                    checked={Boolean(value)}
                    onChange={handleChange(name, type)}
                  />
                  {option.helpText ? <Form.Text>{option.helpText}</Form.Text> : null}
                </div>
              ) : (
                <Form.Group controlId={`${toolKey}-${name}`}>
                  <Form.Label>{option.label}</Form.Label>
                  {type === 'textarea' ? (
                    <Form.Control
                      as="textarea"
                      rows={3}
                      placeholder={option.placeholder}
                      value={value}
                      onChange={handleChange(name, type)}
                      required={option.required}
                    />
                  ) : type === 'select' ? (
                    <Form.Select
                      value={value}
                      onChange={handleChange(name, type)}
                      required={option.required}
                    >
                      {(option.options || []).map((selectOption) => (
                        <option key={selectOption.value} value={selectOption.value}>
                          {selectOption.label}
                        </option>
                      ))}
                    </Form.Select>
                  ) : (
                    <Form.Control
                      type={type}
                      placeholder={option.placeholder}
                      value={value}
                      onChange={handleChange(name, type)}
                      min={option.min}
                      max={option.max}
                      step={option.step}
                      required={option.required}
                    />
                  )}
                  {option.helpText ? <Form.Text>{option.helpText}</Form.Text> : null}
                </Form.Group>
              )}
            </Col>
          );
        })}
      </Row>
    </div>
  );
};

export default ToolOptionForm;




################################################################################
## FILE 24: config.js
## Path: client/src/config.js
################################################################################

export const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:5000/api';




################################################################################
## FILE 25: tools.js
## Path: client/src/constants/tools.js
################################################################################

export const TOOL_DEFINITIONS = {
  nikto: {
    label: 'Nikto',
    description: 'Open-source web server scanner for known vulnerabilities.',
    defaultEnabled: true,
    options: [
      {
        name: 'timeout',
        label: 'Timeout (seconds)',
        type: 'number',
        placeholder: '60',
        min: 1,
        max: 3600,
        serialize: (value) => (value ? Number(value) : undefined),
      },
      {
        name: 'maxTime',
        label: 'Max Time (seconds)',
        type: 'number',
        placeholder: '3600',
        min: 1,
        max: 86400,
        serialize: (value) => (value ? Number(value) : undefined),
      },
      {
        name: 'userAgent',
        label: 'Custom User-Agent',
        type: 'text',
        placeholder: 'ReconWebScanner/1.0',
      },
      {
        name: 'port',
        label: 'Target Port',
        type: 'number',
        placeholder: '443',
        min: 1,
        max: 65535,
        serialize: (value) => (value ? Number(value) : undefined),
      },
      {
        name: 'ssl',
        label: 'Force SSL',
        type: 'checkbox',
        serialize: (value) => Boolean(value),
      },
      {
        name: 'hostHeader',
        label: 'Host Header Override',
        type: 'text',
        placeholder: 'example.com',
      },
      {
        name: 'cookies',
        label: 'Cookies',
        type: 'textarea',
        placeholder: 'sessionid=abc123; theme=dark',
      },
      {
        name: 'plugins',
        label: 'Plugins',
        type: 'text',
        placeholder: 'apache_expect_xss',
      },
    ],
  },
  gobuster: {
    label: 'Gobuster',
    description: 'Directory/DNS/Fuzzing brute forcing tool.',
    defaultEnabled: true,
    options: [
      {
        name: 'mode',
        label: 'Mode',
        type: 'select',
        options: [
          { value: 'dir', label: 'Directory' },
          { value: 'dns', label: 'DNS' },
          { value: 'vhost', label: 'Virtual Host' },
          { value: 'fuzz', label: 'Fuzz' },
        ],
        defaultValue: 'dir',
      },
      {
        name: 'wordlist',
        label: 'Wordlist Path',
        type: 'text',
        placeholder: '/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt',
        required: true,
        serialize: (value) => (value ? value.trim() : undefined),
      },
      {
        name: 'extensions',
        label: 'Extensions',
        type: 'text',
        placeholder: 'php,html,js',
      },
      {
        name: 'statusCodes',
        label: 'Status Codes',
        type: 'text',
        placeholder: '200,204,301,302,307,403',
      },
      {
        name: 'threads',
        label: 'Threads',
        type: 'number',
        placeholder: '32',
        min: 1,
        max: 200,
        serialize: (value) => (value ? Number(value) : undefined),
      },
      {
        name: 'delay',
        label: 'Delay (seconds)',
        type: 'number',
        placeholder: '0',
        min: 0,
        max: 10,
        step: '0.1',
        serialize: (value) => (value ? Number(value) : undefined),
      },
      {
        name: 'timeout',
        label: 'Timeout (seconds)',
        type: 'number',
        placeholder: '30',
        min: 1,
        max: 300,
        serialize: (value) => (value ? Number(value) : undefined),
      },
      {
        name: 'userAgent',
        label: 'User-Agent',
        type: 'text',
        placeholder: 'ReconWebGobuster/1.0',
      },
      {
        name: 'proxy',
        label: 'Proxy',
        type: 'text',
        placeholder: 'http://127.0.0.1:8080',
      },
      {
        name: 'followRedirect',
        label: 'Follow Redirects',
        type: 'checkbox',
        serialize: (value) => Boolean(value),
      },
      {
        name: 'includeLength',
        label: 'Include Body Length',
        type: 'checkbox',
        serialize: (value) => Boolean(value),
      },
      {
        name: 'noTlsValidation',
        label: 'Skip TLS Verification',
        type: 'checkbox',
        serialize: (value) => Boolean(value),
      },
      {
        name: 'extraArgs',
        label: 'Extra Arguments',
        type: 'textarea',
  placeholder: '--wildcard\n--add-slash',
        serialize: (value) =>
          value
            ? value
                .split('\n')
                .map((line) => line.trim())
                .filter((line) => line.length > 0)
            : undefined,
      },
    ],
  },
  nuclei: {
    label: 'Nuclei',
    description: 'Fast template-based vulnerability scanner.',
    defaultEnabled: false,
    options: [
      {
        name: 'templates',
        label: 'Templates',
        type: 'textarea',
        placeholder: '/path/to/template.yaml',
        serialize: (value) =>
          value
            ? value
                .split('\n')
                .map((line) => line.trim())
                .filter((line) => line.length > 0)
            : undefined,
      },
      {
        name: 'severity',
        label: 'Severity Filter',
        type: 'text',
        placeholder: 'critical,high',
      },
      {
        name: 'tags',
        label: 'Tags',
        type: 'text',
        placeholder: 'cve,dos',
      },
      {
        name: 'excludeTags',
        label: 'Exclude Tags',
        type: 'text',
        placeholder: 'info',
      },
      {
        name: 'rateLimit',
        label: 'Rate Limit (req/s)',
        type: 'number',
        placeholder: '100',
        min: 1,
        max: 10000,
        serialize: (value) => (value ? Number(value) : undefined),
      },
      {
        name: 'bulkSize',
        label: 'Bulk Size',
        type: 'number',
        placeholder: '25',
        min: 1,
        max: 1000,
        serialize: (value) => (value ? Number(value) : undefined),
      },
      {
        name: 'concurrency',
        label: 'Concurrency',
        type: 'number',
        placeholder: '10',
        min: 1,
        max: 500,
        serialize: (value) => (value ? Number(value) : undefined),
      },
      {
        name: 'headless',
        label: 'Headless Browser Mode',
        type: 'checkbox',
        serialize: (value) => Boolean(value),
      },
      {
        name: 'proxy',
        label: 'Proxy',
        type: 'text',
        placeholder: 'http://127.0.0.1:8080',
      },
      {
        name: 'resolvers',
        label: 'Custom Resolvers',
        type: 'text',
        placeholder: '/etc/resolvers.txt',
      },
      {
        name: 'extraArgs',
        label: 'Extra Arguments',
        type: 'textarea',
  placeholder: '-duc\n--silent',
        serialize: (value) =>
          value
            ? value
                .split('\n')
                .map((line) => line.trim())
                .filter((line) => line.length > 0)
            : undefined,
      },
    ],
  },
  sqlmap: {
    label: 'SQLMap',
    description: 'Automatic SQL injection detection and exploitation tool.',
    defaultEnabled: false,
    options: [
      {
        name: 'batch',
        label: 'Batch Mode',
        type: 'checkbox',
        serialize: (value) => Boolean(value),
      },
      {
        name: 'risk',
        label: 'Risk',
        type: 'number',
        placeholder: '1-3',
        min: 0,
        max: 3,
        serialize: (value) => (value ? Number(value) : undefined),
      },
      {
        name: 'level',
        label: 'Level',
        type: 'number',
        placeholder: '1-5',
        min: 1,
        max: 5,
        serialize: (value) => (value ? Number(value) : undefined),
      },
      {
        name: 'threads',
        label: 'Threads',
        type: 'number',
        placeholder: '1-10',
        min: 1,
        max: 10,
        serialize: (value) => (value ? Number(value) : undefined),
      },
      {
        name: 'tamper',
        label: 'Tamper Scripts',
        type: 'text',
        placeholder: 'between,space2comment',
      },
      {
        name: 'dbms',
        label: 'DBMS',
        type: 'text',
        placeholder: 'MySQL',
      },
      {
        name: 'os',
        label: 'Operating System',
        type: 'text',
        placeholder: 'Linux',
      },
      {
        name: 'tech',
        label: 'Techniques',
        type: 'text',
        placeholder: 'BEUSTQ',
      },
      {
        name: 'timeout',
        label: 'Timeout (seconds)',
        type: 'number',
        placeholder: '30',
        min: 1,
        max: 600,
        serialize: (value) => (value ? Number(value) : undefined),
      },
      {
        name: 'delay',
        label: 'Delay (seconds)',
        type: 'number',
        placeholder: '0',
        min: 0,
        max: 10,
        step: '0.1',
        serialize: (value) => (value ? Number(value) : undefined),
      },
      {
        name: 'tor',
        label: 'Use Tor',
        type: 'checkbox',
        serialize: (value) => Boolean(value),
      },
      {
        name: 'randomAgent',
        label: 'Random User-Agent',
        type: 'checkbox',
        serialize: (value) => Boolean(value),
      },
      {
        name: 'extraArgs',
        label: 'Extra Arguments',
        type: 'textarea',
        placeholder: '--fresh-queries',
        serialize: (value) =>
          value
            ? value
                .split('\n')
                .map((line) => line.trim())
                .filter((line) => line.length > 0)
            : undefined,
      },
    ],
  },
  xsstrike: {
    label: 'XSStrike',
    description: 'Intelligent XSS detection suite.',
    defaultEnabled: false,
    options: [
      {
        name: 'crawl',
        label: 'Crawl Target',
        type: 'checkbox',
        serialize: (value) => Boolean(value),
      },
      {
        name: 'blind',
        label: 'Enable Blind Payloads',
        type: 'checkbox',
        serialize: (value) => Boolean(value),
      },
      {
        name: 'skip',
        label: 'Skip Parameter Discovery',
        type: 'checkbox',
        serialize: (value) => Boolean(value),
      },
      {
        name: 'fuzz',
        label: 'Enable Fuzzer',
        type: 'checkbox',
        serialize: (value) => Boolean(value),
      },
      {
        name: 'delay',
        label: 'Delay (seconds)',
        type: 'number',
        placeholder: '0',
        min: 0,
        max: 10,
        serialize: (value) => (value ? Number(value) : undefined),
      },
      {
        name: 'headers',
        label: 'Custom Headers',
        type: 'textarea',
        placeholder: 'Authorization: Bearer token',
      },
      {
        name: 'threads',
        label: 'Threads',
        type: 'number',
        placeholder: '4',
        min: 1,
        max: 20,
        serialize: (value) => (value ? Number(value) : undefined),
      },
      {
        name: 'extraArgs',
        label: 'Extra Arguments',
        type: 'textarea',
  placeholder: '--skip-dom\n--data "q=test"',
        serialize: (value) =>
          value
            ? value
                .split('\n')
                .map((line) => line.trim())
                .filter((line) => line.length > 0)
            : undefined,
      },
    ],
  },
  wpscan: {
    label: 'WPScan',
    description: 'WordPress vulnerability scanner for security assessments.',
    defaultEnabled: true,
    options: [
      {
        name: 'apiToken',
        label: 'WPScan API Token',
        type: 'text',
        placeholder: 'Your WPScan API token for vulnerability data',
      },
      {
        name: 'enumeratePlugins',
        label: 'Enumerate Plugins',
        type: 'select',
        options: [
          { value: '', label: 'None' },
          { value: 'p', label: 'Popular plugins' },
          { value: 'vp', label: 'Vulnerable plugins' },
          { value: 'ap', label: 'All plugins' },
        ],
        defaultValue: '',
      },
      {
        name: 'enumerateThemes',
        label: 'Enumerate Themes',
        type: 'select',
        options: [
          { value: '', label: 'None' },
          { value: 't', label: 'Popular themes' },
          { value: 'vt', label: 'Vulnerable themes' },
          { value: 'at', label: 'All themes' },
        ],
        defaultValue: '',
      },
      {
        name: 'enumerateUsers',
        label: 'Enumerate Users',
        type: 'select',
        options: [
          { value: '', label: 'None' },
          { value: 'u', label: 'User IDs 1-10' },
          { value: 'u[1-100]', label: 'User IDs 1-100' },
        ],
        defaultValue: '',
      },
      {
        name: 'randomUserAgent',
        label: 'Random User-Agent',
        type: 'checkbox',
        serialize: (value) => Boolean(value),
      },
      {
        name: 'disableTlsChecks',
        label: 'Disable TLS Checks',
        type: 'checkbox',
        serialize: (value) => Boolean(value),
      },
      {
        name: 'ignoreMainRedirect',
        label: 'Ignore Main Redirect',
        type: 'checkbox',
        serialize: (value) => Boolean(value),
      },
      {
        name: 'userAgent',
        label: 'Custom User-Agent',
        type: 'text',
        placeholder: 'Mozilla/5.0 (compatible; WPScan)',
      },
      {
        name: 'proxy',
        label: 'Proxy URL',
        type: 'text',
        placeholder: 'http://127.0.0.1:8080',
      },
      {
        name: 'cookieString',
        label: 'Cookie String',
        type: 'text',
        placeholder: 'wordpress_logged_in=xxx; wp-settings=xxx',
      },
      {
        name: 'maxThreads',
        label: 'Max Threads',
        type: 'number',
        placeholder: '5',
        min: 1,
        max: 50,
        serialize: (value) => (value ? Number(value) : undefined),
      },
      {
        name: 'throttle',
        label: 'Throttle (ms)',
        type: 'number',
        placeholder: '0',
        min: 0,
        max: 5000,
        serialize: (value) => (value ? Number(value) : undefined),
      },
      {
        name: 'requestTimeout',
        label: 'Request Timeout (seconds)',
        type: 'number',
        placeholder: '60',
        min: 1,
        max: 600,
        serialize: (value) => (value ? Number(value) : undefined),
      },
      {
        name: 'connectTimeout',
        label: 'Connect Timeout (seconds)',
        type: 'number',
        placeholder: '30',
        min: 1,
        max: 300,
        serialize: (value) => (value ? Number(value) : undefined),
      },
      {
        name: 'stealthy',
        label: 'Stealthy Mode',
        type: 'checkbox',
        serialize: (value) => Boolean(value),
      },
      {
        name: 'extraArgs',
        label: 'Extra Arguments',
        type: 'textarea',
        placeholder: '--force\n--verbose',
        serialize: (value) =>
          value
            ? value
                .split('\n')
                .map((line) => line.trim())
                .filter((line) => line.length > 0)
            : undefined,
      },
    ],
  },
};

export const SUPPORTED_TOOLS = Object.keys(TOOL_DEFINITIONS);




################################################################################
## FILE 26: AuthContext.jsx
## Path: client/src/context/AuthContext.jsx
################################################################################

import { createContext, useContext, useEffect, useMemo, useState } from 'react';
import { apiRequest } from '../services/apiClient';

const AuthContext = createContext();

const TOKEN_STORAGE_KEY = 'reconweb_token';

export const AuthProvider = ({ children }) => {
  const [token, setToken] = useState(() => localStorage.getItem(TOKEN_STORAGE_KEY));
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(Boolean(token));
  const [error, setError] = useState(null);

  useEffect(() => {
    const bootstrap = async () => {
      if (!token) {
        setLoading(false);
        return;
      }

      try {
        const response = await apiRequest('/auth/me', { token });
        setUser(response.user);
      } catch (err) {
        console.error('Failed to restore session', err);
        localStorage.removeItem(TOKEN_STORAGE_KEY);
        setToken(null);
      } finally {
        setLoading(false);
      }
    };

    bootstrap();
  }, [token]);

  const handleAuthSuccess = (payload) => {
    setToken(payload.token);
    localStorage.setItem(TOKEN_STORAGE_KEY, payload.token);
    setUser(payload.user);
  };

  const login = async (credentials) => {
    setError(null);
    const payload = await apiRequest('/auth/login', { method: 'POST', body: credentials });
    handleAuthSuccess(payload);
    return payload;
  };

  const register = async (data) => {
    setError(null);
    const payload = await apiRequest('/auth/register', { method: 'POST', body: data });
    handleAuthSuccess(payload);
    return payload;
  };

  const logout = () => {
    localStorage.removeItem(TOKEN_STORAGE_KEY);
    setToken(null);
    setUser(null);
  };

  const authorizedRequest = async (path, options = {}) => {
    if (!token) {
      throw new Error('Not authenticated');
    }

    try {
      return await apiRequest(path, { ...options, token });
    } catch (err) {
      if (err.status === 401) {
        logout();
      }
      throw err;
    }
  };

  const value = useMemo(
    () => ({
      user,
      token,
      loading,
      error,
      login,
      register,
      logout,
      request: authorizedRequest,
      isAuthenticated: Boolean(user && token),
      setError,
    }),
    [user, token, loading, error]
  );

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};




################################################################################
## FILE 27: index.css
## Path: client/src/index.css
################################################################################

@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  @apply bg-slate-100 text-slate-800;
  margin: 0;
}




################################################################################
## FILE 28: main.jsx
## Path: client/src/main.jsx
################################################################################

import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import 'bootstrap/dist/css/bootstrap.min.css';
import './index.css';
import App from './App.jsx';

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
);




################################################################################
## FILE 29: CodeReviewPage.jsx
## Path: client/src/pages/CodeReviewPage.jsx
################################################################################

import { useState, useEffect } from 'react';
import { Container, Row, Col, Card, Form, Button, Badge, Alert, Spinner, Tab, Tabs, ListGroup, Accordion } from 'react-bootstrap';
import { apiRequest } from '../services/apiClient';
import { useAuth } from '../context/AuthContext';
import { FaCode, FaShieldAlt, FaExclamationTriangle, FaCheckCircle, FaBug, FaHistory, FaChartBar, FaTrash } from 'react-icons/fa';

const LANGUAGES = [
  { value: 'javascript', label: 'JavaScript' },
  { value: 'typescript', label: 'TypeScript' },
  { value: 'python', label: 'Python' },
  { value: 'java', label: 'Java' },
  { value: 'php', label: 'PHP' },
  { value: 'csharp', label: 'C#' },
  { value: 'go', label: 'Go' },
  { value: 'ruby', label: 'Ruby' },
  { value: 'sql', label: 'SQL' },
  { value: 'html', label: 'HTML/CSS' },
  { value: 'other', label: 'Other' }
];

const CodeReviewPage = () => {
  const { user, token } = useAuth();
  const [activeTab, setActiveTab] = useState('review');
  const [code, setCode] = useState('');
  const [language, setLanguage] = useState('javascript');
  const [title, setTitle] = useState('');
  const [loading, setLoading] = useState(false);
  const [reviewing, setReviewing] = useState(false);
  const [result, setResult] = useState(null);
  const [history, setHistory] = useState([]);
  const [stats, setStats] = useState(null);
  const [error, setError] = useState('');
  const [canReview, setCanReview] = useState({ allowed: true });

  useEffect(() => {
    checkCanReview();
    if (activeTab === 'history') {
      fetchHistory();
    } else if (activeTab === 'stats') {
      fetchStats();
    }
  }, [activeTab]);

  const checkCanReview = async () => {
    try {
      const res = await apiRequest('/subscription/can-review', { token });
      setCanReview(res);
    } catch (err) {
      console.error('Error checking review availability:', err);
    }
  };

  const fetchHistory = async () => {
    try {
      setLoading(true);
      const res = await apiRequest('/code-review/history', { token });
      setHistory(res.reviews || []);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  const fetchStats = async () => {
    try {
      setLoading(true);
      const res = await apiRequest('/code-review/stats', { token });
      setStats(res);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!code.trim()) {
      setError('Please enter code to review');
      return;
    }

    try {
      setReviewing(true);
      setError('');
      setResult(null);

      const res = await apiRequest('/code-review/review', {
        method: 'POST',
        body: { code, language, title: title || 'Untitled Review' },
        token
      });

      setResult(res);
      checkCanReview();
    } catch (err) {
      setError(err.message);
    } finally {
      setReviewing(false);
    }
  };

  const handleDeleteReview = async (reviewId) => {
    if (!window.confirm('Are you sure you want to delete this review?')) return;

    try {
      await apiRequest(`/code-review/${reviewId}`, {
        method: 'DELETE',
        token
      });
      fetchHistory();
    } catch (err) {
      setError(err.message);
    }
  };

  const getSeverityBadge = (severity) => {
    const variants = {
      critical: 'danger',
      high: 'warning',
      medium: 'info',
      low: 'secondary',
      info: 'light'
    };
    return <Badge bg={variants[severity] || 'secondary'}>{severity}</Badge>;
  };

  const getRiskBadge = (risk) => {
    const variants = {
      critical: 'danger',
      high: 'warning',
      medium: 'info',
      low: 'secondary',
      secure: 'success'
    };
    return <Badge bg={variants[risk] || 'secondary'} className="fs-6">{risk}</Badge>;
  };

  return (
    <Container className="py-4">
      <h1 className="mb-4">
        <FaCode className="me-2" />
        AI Code Security Review
      </h1>

      {error && <Alert variant="danger" dismissible onClose={() => setError('')}>{error}</Alert>}

      {!canReview.allowed && (
        <Alert variant="warning">
          {canReview.reason}
          <Button variant="link" href="/subscription" className="p-0 ms-2">
            Upgrade Plan
          </Button>
        </Alert>
      )}

      <Tabs activeKey={activeTab} onSelect={setActiveTab} className="mb-4">
        <Tab eventKey="review" title={<><FaShieldAlt className="me-1" /> New Review</>}>
          <Row>
            <Col lg={6}>
              <Card className="mb-4">
                <Card.Header>
                  <h5 className="mb-0">Submit Code for Review</h5>
                </Card.Header>
                <Card.Body>
                  <Form onSubmit={handleSubmit}>
                    <Form.Group className="mb-3">
                      <Form.Label>Title (optional)</Form.Label>
                      <Form.Control
                        type="text"
                        placeholder="e.g., Login form validation"
                        value={title}
                        onChange={(e) => setTitle(e.target.value)}
                      />
                    </Form.Group>

                    <Form.Group className="mb-3">
                      <Form.Label>Programming Language</Form.Label>
                      <Form.Select value={language} onChange={(e) => setLanguage(e.target.value)}>
                        {LANGUAGES.map((lang) => (
                          <option key={lang.value} value={lang.value}>{lang.label}</option>
                        ))}
                      </Form.Select>
                    </Form.Group>

                    <Form.Group className="mb-3">
                      <Form.Label>Code to Review</Form.Label>
                      <Form.Control
                        as="textarea"
                        rows={12}
                        placeholder="Paste your code here..."
                        value={code}
                        onChange={(e) => setCode(e.target.value)}
                        style={{ fontFamily: 'monospace' }}
                      />
                      <Form.Text className="text-muted">
                        Maximum 50,000 characters
                      </Form.Text>
                    </Form.Group>

                    <Button 
                      type="submit" 
                      variant="primary" 
                      size="lg" 
                      className="w-100"
                      disabled={reviewing || !canReview.allowed}
                    >
                      {reviewing ? (
                        <>
                          <Spinner animation="border" size="sm" className="me-2" />
                          Analyzing Code...
                        </>
                      ) : (
                        <>
                          <FaShieldAlt className="me-2" />
                          Review Code
                        </>
                      )}
                    </Button>
                  </Form>
                </Card.Body>
              </Card>
            </Col>

            <Col lg={6}>
              {result && (
                <Card className="mb-4">
                  <Card.Header className="d-flex justify-content-between align-items-center">
                    <h5 className="mb-0">Security Review Results</h5>
                    {getRiskBadge(result.overallRisk)}
                  </Card.Header>
                  <Card.Body>
                    {result.summary && (
                      <Alert variant={result.overallRisk === 'secure' ? 'success' : 'warning'}>
                        {result.summary}
                      </Alert>
                    )}

                    {result.vulnerabilities && result.vulnerabilities.length > 0 ? (
                      <Accordion defaultActiveKey="0">
                        {result.vulnerabilities.map((vuln, idx) => (
                          <Accordion.Item key={idx} eventKey={idx.toString()}>
                            <Accordion.Header>
                              <span className="me-2">{getSeverityBadge(vuln.severity)}</span>
                              {vuln.type}
                              {vuln.line && <small className="text-muted ms-2">Line {vuln.line}</small>}
                            </Accordion.Header>
                            <Accordion.Body>
                              <p><strong>Description:</strong> {vuln.description}</p>
                              <p><strong>Recommendation:</strong> {vuln.recommendation}</p>
                              {vuln.fixedCode && (
                                <div>
                                  <strong>Fixed Code:</strong>
                                  <pre className="bg-light p-2 rounded mt-2">
                                    <code>{vuln.fixedCode}</code>
                                  </pre>
                                </div>
                              )}
                            </Accordion.Body>
                          </Accordion.Item>
                        ))}
                      </Accordion>
                    ) : (
                      <Alert variant="success">
                        <FaCheckCircle className="me-2" />
                        No security vulnerabilities detected in this code!
                      </Alert>
                    )}

                    {result.aiResponse?.bestPractices && result.aiResponse.bestPractices.length > 0 && (
                      <div className="mt-4">
                        <h6>Best Practices:</h6>
                        <ul>
                          {result.aiResponse.bestPractices.map((practice, idx) => (
                            <li key={idx}>{practice}</li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </Card.Body>
                </Card>
              )}

              {!result && !reviewing && (
                <Card className="text-center py-5">
                  <Card.Body>
                    <FaBug size={48} className="text-muted mb-3" />
                    <h5>Ready to Review</h5>
                    <p className="text-muted">
                      Paste your code on the left and click "Review Code" to get an AI-powered security analysis.
                    </p>
                  </Card.Body>
                </Card>
              )}
            </Col>
          </Row>
        </Tab>

        <Tab eventKey="history" title={<><FaHistory className="me-1" /> History</>}>
          {loading ? (
            <div className="text-center py-5">
              <Spinner animation="border" />
            </div>
          ) : history.length === 0 ? (
            <Alert variant="info">No code reviews yet. Submit your first code review above!</Alert>
          ) : (
            <ListGroup>
              {history.map((review) => (
                <ListGroup.Item key={review._id} className="d-flex justify-content-between align-items-start">
                  <div>
                    <h6 className="mb-1">{review.title}</h6>
                    <small className="text-muted">
                      {review.language} ‚Ä¢ {new Date(review.createdAt).toLocaleString()}
                    </small>
                    <div className="mt-1">
                      <Badge bg="secondary" className="me-2">{review.status}</Badge>
                      {review.overallRisk && getRiskBadge(review.overallRisk)}
                      {review.vulnerabilities?.length > 0 && (
                        <Badge bg="warning" className="ms-2">
                          {review.vulnerabilities.length} issues
                        </Badge>
                      )}
                    </div>
                  </div>
                  <Button 
                    variant="outline-danger" 
                    size="sm"
                    onClick={() => handleDeleteReview(review._id)}
                  >
                    <FaTrash />
                  </Button>
                </ListGroup.Item>
              ))}
            </ListGroup>
          )}
        </Tab>

        <Tab eventKey="stats" title={<><FaChartBar className="me-1" /> Statistics</>}>
          {loading ? (
            <div className="text-center py-5">
              <Spinner animation="border" />
            </div>
          ) : stats ? (
            <Row>
              <Col md={3}>
                <Card className="text-center mb-3">
                  <Card.Body>
                    <h2>{stats.totalReviews}</h2>
                    <p className="text-muted mb-0">Total Reviews</p>
                  </Card.Body>
                </Card>
              </Col>
              <Col md={3}>
                <Card className="text-center mb-3">
                  <Card.Body>
                    <h2>{stats.completedReviews}</h2>
                    <p className="text-muted mb-0">Completed</p>
                  </Card.Body>
                </Card>
              </Col>
              <Col md={3}>
                <Card className="text-center mb-3 border-danger">
                  <Card.Body>
                    <h2 className="text-danger">{stats.criticalVulns}</h2>
                    <p className="text-muted mb-0">Critical Issues</p>
                  </Card.Body>
                </Card>
              </Col>
              <Col md={3}>
                <Card className="text-center mb-3 border-warning">
                  <Card.Body>
                    <h2 className="text-warning">{stats.highVulns}</h2>
                    <p className="text-muted mb-0">High Issues</p>
                  </Card.Body>
                </Card>
              </Col>
            </Row>
          ) : (
            <Alert variant="info">No statistics available yet.</Alert>
          )}
        </Tab>
      </Tabs>
    </Container>
  );
};

export default CodeReviewPage;




################################################################################
## FILE 30: DashboardPage.jsx
## Path: client/src/pages/DashboardPage.jsx
################################################################################

import { useEffect, useMemo, useState } from 'react';
import { Alert, Badge, Button, Card, Col, Form, Row, Stack } from 'react-bootstrap';
import { Link, useNavigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';
import ToolOptionForm from '../components/ToolOptionForm';
import ScanProgress from '../components/ScanProgress';
import { SUPPORTED_TOOLS, TOOL_DEFINITIONS } from '../constants/tools';
import { apiRequest } from '../services/apiClient';

const buildInitialSelection = (installedTools = []) =>
  SUPPORTED_TOOLS.filter((tool) => 
    TOOL_DEFINITIONS[tool].defaultEnabled && installedTools.includes(tool)
  );

const buildInitialOptions = () => {
  const initial = {};
  SUPPORTED_TOOLS.forEach((tool) => {
    initial[tool] = {};
    TOOL_DEFINITIONS[tool].options.forEach((option) => {
      if (option.defaultValue !== undefined) {
        initial[tool][option.name] = option.defaultValue;
      }
    });
  });
  return initial;
};

const DashboardPage = () => {
  const { request } = useAuth();
  const navigate = useNavigate();
  const [targetUrl, setTargetUrl] = useState('');
  const [notes, setNotes] = useState('');
  const [selectedTools, setSelectedTools] = useState([]);
  const [toolOptions, setToolOptions] = useState(buildInitialOptions);
  const [submitting, setSubmitting] = useState(false);
  const [feedback, setFeedback] = useState({ type: null, message: null });
  const [activeScanId, setActiveScanId] = useState(null);
  const [installedTools, setInstalledTools] = useState([]);
  const [notInstalledTools, setNotInstalledTools] = useState([]);
  const [loadingTools, setLoadingTools] = useState(true);

  // Load danh s√°ch tool ƒë√£ c√†i ƒë·∫∑t
  useEffect(() => {
    const fetchInstalledTools = async () => {
      try {
        const data = await apiRequest('/scans/tools/installed');
        setInstalledTools(data.installed || []);
        setNotInstalledTools(data.notInstalled || []);
        setSelectedTools(buildInitialSelection(data.installed || []));
      } catch (error) {
        console.error('Failed to fetch installed tools:', error);
        // Fallback to all tools if API fails
        setInstalledTools(SUPPORTED_TOOLS);
        setSelectedTools(buildInitialSelection(SUPPORTED_TOOLS));
      } finally {
        setLoadingTools(false);
      }
    };
    fetchInstalledTools();
  }, []);

  const availableTools = useMemo(
    () =>
      SUPPORTED_TOOLS
        .filter((toolKey) => installedTools.includes(toolKey))
        .map((toolKey) => ({
          key: toolKey,
          label: TOOL_DEFINITIONS[toolKey].label,
          description: TOOL_DEFINITIONS[toolKey].description,
        })),
    [installedTools]
  );

  const handleToolToggle = (toolKey) => {
    setSelectedTools((prev) =>
      prev.includes(toolKey) ? prev.filter((key) => key !== toolKey) : [...prev, toolKey]
    );
  };

  const handleOptionChange = (toolKey, optionName, value) => {
    setToolOptions((prev) => ({
      ...prev,
      [toolKey]: {
        ...prev[toolKey],
        [optionName]: value,
      },
    }));
  };

  const prepareToolPayload = (toolKey) => {
    const toolDefinition = TOOL_DEFINITIONS[toolKey];
    const storedOptions = toolOptions[toolKey] || {};
    const optionsPayload = {};

    toolDefinition.options.forEach((option) => {
      const rawValue = storedOptions[option.name];
      const serializer = option.serialize;
      const serialized = serializer ? serializer(rawValue) : rawValue;

      const shouldSkip =
        serialized === undefined ||
        serialized === null ||
        serialized === '' ||
        serialized === false ||
        (Array.isArray(serialized) && serialized.length === 0);

      if (!shouldSkip) {
        optionsPayload[option.name] = serialized;
      }
    });

    return {
      tool: toolKey,
      options: optionsPayload,
    };
  };

  const handleSubmit = async (event) => {
    event.preventDefault();
    if (!selectedTools.length) {
      setFeedback({ type: 'danger', message: 'Please choose at least one tool to run the scan.' });
      return;
    }

    setSubmitting(true);
    setFeedback({ type: null, message: null });
    setActiveScanId(null);

    try {
      const tools = selectedTools.map(prepareToolPayload);
      const payload = {
        url: targetUrl,
        notes,
        tools,
      };

      const response = await request('/scans', { method: 'POST', body: payload });
      setActiveScanId(response._id);
      setFeedback({ type: 'info', message: 'Scan started! Progress will update automatically.' });
    } catch (error) {
      setFeedback({ type: 'danger', message: error.message || 'Failed to start scan. Please try again.' });
      setSubmitting(false);
    }
  };

  const handleScanComplete = (completedScan) => {
    setSubmitting(false);
    if (completedScan.status === 'completed') {
      setFeedback({ type: 'success', message: 'Scan completed successfully!' });
      // Redirect to scan details sau 2 gi√¢y
      setTimeout(() => {
        navigate(`/scans/${completedScan._id}`);
      }, 2000);
    } else {
      setFeedback({ type: 'warning', message: 'Scan finished with some errors. Check the details.' });
    }
  };

  return (
    <Stack gap={4}>
      <div className="bg-white shadow-sm p-4 rounded-3">
        <div className="d-flex flex-column flex-md-row justify-content-between align-items-md-center gap-3 mb-4">
          <div>
            <h1 className="mb-1">Automation Dashboard</h1>
            <p className="mb-0 text-muted">Configure and run vulnerability scans using open-source tools.</p>
          </div>
          <Button as={Link} to="/history" variant="outline-primary">
            View Scan History
          </Button>
        </div>
        {feedback.message ? <Alert variant={feedback.type}>{feedback.message}</Alert> : null}
        <Form onSubmit={handleSubmit}>
          <Row className="g-4">
            <Col xs={12}>
              <Form.Group controlId="targetUrl">
                <Form.Label>Target URL</Form.Label>
                <Form.Control
                  type="url"
                  placeholder="https://example.com"
                  value={targetUrl}
                  onChange={(event) => setTargetUrl(event.target.value)}
                  required
                />
                <Form.Text>Include the protocol (http or https) for the target website.</Form.Text>
              </Form.Group>
            </Col>
            <Col xs={12}>
              <Form.Group controlId="scanNotes">
                <Form.Label>Notes (optional)</Form.Label>
                <Form.Control
                  as="textarea"
                  rows={2}
                  placeholder="Describe the goal of this scan or additional context."
                  value={notes}
                  onChange={(event) => setNotes(event.target.value)}
                />
              </Form.Group>
            </Col>
          </Row>

          <div className="mt-4">
            <h4 className="mb-3">Select Tools</h4>
            {loadingTools ? (
              <div className="text-center py-4">
                <div className="spinner-border text-primary" role="status">
                  <span className="visually-hidden">Loading...</span>
                </div>
                <p className="mt-2 text-muted">Checking installed tools...</p>
              </div>
            ) : (
              <>
                {notInstalledTools.length > 0 && (
                  <Alert variant="warning" className="mb-3">
                    <strong>Some tools are not installed:</strong>{' '}
                    {notInstalledTools.map(t => TOOL_DEFINITIONS[t]?.label || t).join(', ')}.
                    <br />
                    <small>Please install them to use in scans.</small>
                  </Alert>
                )}
                {availableTools.length === 0 ? (
                  <Alert variant="danger">
                    No scanning tools are installed on the server. Please install at least one tool (nikto, gobuster, nuclei, sqlmap, xsstrike, or wpscan).
                  </Alert>
                ) : (
                  <Row className="g-3">
                    {availableTools.map((tool) => (
                      <Col xs={12} md={6} lg={4} key={tool.key}>
                        <Card className={selectedTools.includes(tool.key) ? 'border-primary shadow-sm' : 'shadow-sm'}>
                          <Card.Body>
                            <div className="d-flex justify-content-between align-items-start">
                              <div>
                                <Card.Title>{tool.label}</Card.Title>
                                <Card.Text className="small text-muted">{tool.description}</Card.Text>
                              </div>
                              <Form.Check
                                type="switch"
                                id={`select-${tool.key}`}
                                checked={selectedTools.includes(tool.key)}
                                onChange={() => handleToolToggle(tool.key)}
                                label=""
                              />
                            </div>
                          </Card.Body>
                        </Card>
                      </Col>
                    ))}
                  </Row>
                )}
              </>
            )}
          </div>

          {selectedTools.map((toolKey) => (
            <ToolOptionForm
              key={toolKey}
              toolKey={toolKey}
              values={toolOptions[toolKey]}
              onChange={handleOptionChange}
            />
          ))}

          <div className="d-flex justify-content-end">
            <Button type="submit" variant="primary" size="lg" disabled={submitting}>
              {submitting ? 'Scanning...' : 'Start Scan'}
            </Button>
          </div>
        </Form>
      </div>

      {activeScanId && (
        <ScanProgress 
          scanId={activeScanId} 
          onComplete={handleScanComplete}
          request={request}
        />
      )}
    </Stack>
  );
};

export default DashboardPage;




################################################################################
## FILE 31: LoginPage.jsx
## Path: client/src/pages/LoginPage.jsx
################################################################################

import { useState } from 'react';
import { Button, Card, Col, Container, Form, Row, Alert } from 'react-bootstrap';
import { Link, useLocation, useNavigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

const LoginPage = () => {
  const { login } = useAuth();
  const navigate = useNavigate();
  const location = useLocation();
  const [form, setForm] = useState({ email: '', password: '' });
  const [submitting, setSubmitting] = useState(false);
  const [error, setError] = useState(null);

  const handleChange = (event) => {
    const { name, value } = event.target;
    setForm((prev) => ({ ...prev, [name]: value }));
  };

  const handleSubmit = async (event) => {
    event.preventDefault();
    setSubmitting(true);
    setError(null);

    try {
      await login(form);
      const redirectTo = location.state?.from?.pathname || '/';
      navigate(redirectTo, { replace: true });
    } catch (err) {
      console.error('Login error:', err);
      // Handle validation errors from express-validator
      if (err.payload?.errors && Array.isArray(err.payload.errors)) {
        const messages = err.payload.errors.map(e => e.msg).join(', ');
        setError(messages);
      } else {
        setError(err.message || 'Login failed');
      }
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <Container className="d-flex align-items-center justify-content-center min-vh-100 bg-body-secondary">
      <Row className="w-100 justify-content-center">
        <Col xs={12} md={6} lg={4}>
          <Card className="shadow-sm">
            <Card.Body>
              <h2 className="text-center mb-4">Welcome back</h2>
              {error ? <Alert variant="danger">{error}</Alert> : null}
              <Form onSubmit={handleSubmit}>
                <Form.Group className="mb-3" controlId="loginEmail">
                  <Form.Label>Email address</Form.Label>
                  <Form.Control
                    type="email"
                    name="email"
                    placeholder="you@example.com"
                    value={form.email}
                    onChange={handleChange}
                    required
                  />
                </Form.Group>
                <Form.Group className="mb-3" controlId="loginPassword">
                  <Form.Label>Password</Form.Label>
                  <Form.Control
                    type="password"
                    name="password"
                    placeholder="Password"
                    value={form.password}
                    onChange={handleChange}
                    required
                  />
                </Form.Group>
                <Button type="submit" variant="primary" className="w-100" disabled={submitting}>
                  {submitting ? 'Signing in‚Ä¶' : 'Sign in'}
                </Button>
              </Form>
              <p className="mt-3 mb-0 text-center">
                Need an account? <Link to="/register">Register</Link>
              </p>
            </Card.Body>
          </Card>
        </Col>
      </Row>
    </Container>
  );
};

export default LoginPage;




################################################################################
## FILE 32: RegisterPage.jsx
## Path: client/src/pages/RegisterPage.jsx
################################################################################

import { useState } from 'react';
import { Alert, Button, Card, Col, Container, Form, Row } from 'react-bootstrap';
import { Link, useNavigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

const RegisterPage = () => {
  const { register } = useAuth();
  const navigate = useNavigate();
  const [form, setForm] = useState({ name: '', email: '', password: '' });
  const [submitting, setSubmitting] = useState(false);
  const [error, setError] = useState(null);

  const handleChange = (event) => {
    const { name, value } = event.target;
    setForm((prev) => ({ ...prev, [name]: value }));
  };

  const handleSubmit = async (event) => {
    event.preventDefault();
    setSubmitting(true);
    setError(null);

    try {
      await register(form);
      navigate('/', { replace: true });
    } catch (err) {
      console.error('Registration error:', err);
      // Handle validation errors from express-validator
      if (err.payload?.errors && Array.isArray(err.payload.errors)) {
        const messages = err.payload.errors.map(e => e.msg).join(', ');
        setError(messages);
      } else {
        setError(err.message || 'Registration failed');
      }
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <Container className="d-flex align-items-center justify-content-center min-vh-100 bg-body-secondary">
      <Row className="w-100 justify-content-center">
        <Col xs={12} md={6} lg={4}>
          <Card className="shadow-sm">
            <Card.Body>
              <h2 className="text-center mb-4">Create account</h2>
              {error ? <Alert variant="danger">{error}</Alert> : null}
              <Form onSubmit={handleSubmit}>
                <Form.Group className="mb-3" controlId="registerName">
                  <Form.Label>Full name</Form.Label>
                  <Form.Control
                    type="text"
                    name="name"
                    placeholder="Nguyen Van A"
                    value={form.name}
                    onChange={handleChange}
                    required
                  />
                </Form.Group>
                <Form.Group className="mb-3" controlId="registerEmail">
                  <Form.Label>Email address</Form.Label>
                  <Form.Control
                    type="email"
                    name="email"
                    placeholder="you@example.com"
                    value={form.email}
                    onChange={handleChange}
                    required
                  />
                </Form.Group>
                <Form.Group className="mb-3" controlId="registerPassword">
                  <Form.Label>Password</Form.Label>
                  <Form.Control
                    type="password"
                    name="password"
                    placeholder="At least 8 characters"
                    value={form.password}
                    onChange={handleChange}
                    required
                  />
                </Form.Group>
                <Button type="submit" variant="primary" className="w-100" disabled={submitting}>
                  {submitting ? 'Creating account‚Ä¶' : 'Register'}
                </Button>
              </Form>
              <p className="mt-3 mb-0 text-center">
                Already have an account? <Link to="/login">Sign in</Link>
              </p>
            </Card.Body>
          </Card>
        </Col>
      </Row>
    </Container>
  );
};

export default RegisterPage;




################################################################################
## FILE 33: ScanDetailsPage.jsx
## Path: client/src/pages/ScanDetailsPage.jsx
################################################################################

import { useEffect, useState } from 'react';
import { useParams, Link } from 'react-router-dom';
import { Alert, Badge, Button, Card, Col, Dropdown, Row, Spinner, Stack } from 'react-bootstrap';
import { useAuth } from '../context/AuthContext';
import { TOOL_DEFINITIONS } from '../constants/tools';
import ScanSummary from '../components/ScanSummary';
import ScanResultAccordion from '../components/ScanResultAccordion';
import RemediationPanel from '../components/RemediationPanel';

const formatDateTime = (value) => new Date(value).toLocaleString();

const downloadBlob = (blob, filename) => {
  const url = window.URL.createObjectURL(blob);
  const anchor = document.createElement('a');
  anchor.href = url;
  anchor.download = filename;
  document.body.appendChild(anchor);
  anchor.click();
  anchor.remove();
  window.URL.revokeObjectURL(url);
};

const ScanDetailsPage = () => {
  const { id } = useParams();
  const { request } = useAuth();
  const [scan, setScan] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchDetails = async () => {
      try {
        const response = await request(`/scans/${id}`);
        setScan(response.scan);
      } catch (err) {
        setError(err.message || 'Unable to load scan details');
      } finally {
        setLoading(false);
      }
    };

    fetchDetails();
  }, [id, request]);

  const handleExport = async (format) => {
    try {
      const blob = await request(`/scans/${id}/export?format=${format}`, { responseType: 'blob' });
      downloadBlob(blob, `scan-${id}.${format}`);
    } catch (err) {
      setError(err.message || 'Export failed');
    }
  };

  if (loading) {
    return (
      <div className="text-center py-5">
        <Spinner animation="border" role="status" />
        <p className="mt-3">Loading scan data‚Ä¶</p>
      </div>
    );
  }

  if (error) {
    return <Alert variant="danger">{error}</Alert>;
  }

  if (!scan) {
    return (
      <Alert variant="warning">
        Scan not found.{' '}
        <Link className="alert-link" to="/history">
          Back to history
        </Link>
      </Alert>
    );
  }

  return (
    <Stack gap={4}>
      <div className="d-flex flex-column flex-md-row justify-content-between align-items-md-center gap-3">
        <div>
          <h1 className="mb-1">Scan Details</h1>
          <p className="mb-0 text-muted">Target: {scan.targetUrl}</p>
        </div>
        <div className="d-flex gap-2">
          <Button as={Link} to="/history" variant="outline-secondary">
            Back to History
          </Button>
          <Dropdown>
            <Dropdown.Toggle variant="primary">Export</Dropdown.Toggle>
            <Dropdown.Menu>
              <Dropdown.Item onClick={() => handleExport('json')}>JSON</Dropdown.Item>
              <Dropdown.Item onClick={() => handleExport('txt')}>Text</Dropdown.Item>
              <Dropdown.Item onClick={() => handleExport('pdf')}>PDF Report</Dropdown.Item>
            </Dropdown.Menu>
          </Dropdown>
        </div>
      </div>

      {/* Hi·ªÉn th·ªã summary */}
      {scan.summary && <ScanSummary summary={scan.summary} />}

      <Card className="shadow-sm">
        <Card.Body>
          <Row className="g-3">
            <Col xs={12} md={6}>
              <div className="fw-semibold">Created</div>
              <div>{formatDateTime(scan.createdAt)}</div>
            </Col>
            <Col xs={12} md={6}>
              <div className="fw-semibold">Last updated</div>
              <div>{formatDateTime(scan.updatedAt)}</div>
            </Col>
            {scan.notes ? (
              <Col xs={12}>
                <div className="fw-semibold">Notes</div>
                <Card className="bg-body-secondary">
                  <Card.Body>{scan.notes}</Card.Body>
                </Card>
              </Col>
            ) : null}
          </Row>
        </Card.Body>
      </Card>

      {/* Hi·ªÉn th·ªã k·∫øt qu·∫£ chi ti·∫øt v·ªõi findings */}
      <div>
        <h4 className="mb-3">Chi ti·∫øt t·ª´ng c√¥ng c·ª•</h4>
        <ScanResultAccordion results={scan.results} />
      </div>

      {/* Remediation Panel */}
      {scan.findings && scan.findings.length > 0 && (
        <RemediationPanel 
          scanId={scan._id} 
          findings={scan.findings} 
          targetUrl={scan.targetUrl} 
        />
      )}
    </Stack>
  );
};

export default ScanDetailsPage;




################################################################################
## FILE 34: ScanHistoryPage.jsx
## Path: client/src/pages/ScanHistoryPage.jsx
################################################################################

import { useEffect, useState } from 'react';
import { Alert, Badge, Button, Card, Col, Dropdown, Row, Spinner, Stack } from 'react-bootstrap';
import { Link } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';
import { TOOL_DEFINITIONS } from '../constants/tools';

const formatDate = (value) => new Date(value).toLocaleString();

const downloadBlob = (blob, filename) => {
  const url = window.URL.createObjectURL(blob);
  const anchor = document.createElement('a');
  anchor.href = url;
  anchor.download = filename;
  document.body.appendChild(anchor);
  anchor.click();
  anchor.remove();
  window.URL.revokeObjectURL(url);
};

const ScanHistoryPage = () => {
  const { request } = useAuth();
  const [scans, setScans] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchHistory = async () => {
      try {
        const response = await request('/scans');
        setScans(response.scans);
      } catch (err) {
        setError(err.message || 'Unable to load scan history');
      } finally {
        setLoading(false);
      }
    };

    fetchHistory();
  }, [request]);

  const handleExport = async (scanId, format) => {
    try {
      const blob = await request(`/scans/${scanId}/export?format=${format}`, { responseType: 'blob' });
      downloadBlob(blob, `scan-${scanId}.${format}`);
    } catch (err) {
      setError(err.message || 'Export failed');
    }
  };

  if (loading) {
    return (
      <div className="text-center py-5">
        <Spinner animation="border" role="status" />
        <p className="mt-3">Loading scan history‚Ä¶</p>
      </div>
    );
  }

  return (
    <Stack gap={4}>
      <div className="d-flex justify-content-between align-items-center">
        <div>
          <h1 className="mb-1">Scan History</h1>
          <p className="text-muted mb-0">Review and export results from previous scans.</p>
        </div>
        <Button as={Link} to="/" variant="outline-primary">
          New Scan
        </Button>
      </div>
      {error ? <Alert variant="danger">{error}</Alert> : null}
      {scans.length === 0 ? (
        <Card className="shadow-sm">
          <Card.Body className="text-center py-5">
            <p className="mb-2">No scans found.</p>
            <Button as={Link} to="/" variant="primary">
              Run your first scan
            </Button>
          </Card.Body>
        </Card>
      ) : (
        <Row className="g-3">
          {scans.map((scan) => {
            const summary = scan.summary || {};
            const riskLevel = summary.riskLevel || 'info';
            
            const getRiskColor = (level) => {
              switch (level) {
                case 'critical': return 'danger';
                case 'high': return 'warning';
                case 'medium': return 'info';
                case 'low': return 'primary';
                default: return 'success';
              }
            };

            return (
              <Col xs={12} key={scan._id}>
                <Card className="shadow-sm">
                  <Card.Body>
                    <div className="d-flex flex-column flex-lg-row justify-content-between gap-3">
                      <div className="flex-grow-1">
                        <div className="d-flex align-items-center gap-2 mb-1">
                          <Card.Title className="mb-0">{scan.targetUrl}</Card.Title>
                          {summary.riskLevel && (
                            <Badge bg={getRiskColor(riskLevel)} className="text-uppercase">
                              {riskLevel}
                            </Badge>
                          )}
                        </div>
                        <div className="text-muted small mb-2">{formatDate(scan.createdAt)}</div>
                        
                        {summary.counts && (
                          <div className="mb-2 small">
                            <span className="me-3">
                              üìä T·ªïng: <strong>{summary.counts.total || 0}</strong>
                            </span>
                            {summary.counts.critical > 0 && (
                              <span className="me-3 text-danger">
                                üî¥ Critical: <strong>{summary.counts.critical}</strong>
                              </span>
                            )}
                            {summary.counts.high > 0 && (
                              <span className="me-3 text-warning">
                                üü° High: <strong>{summary.counts.high}</strong>
                              </span>
                            )}
                            {summary.counts.medium > 0 && (
                              <span className="me-3 text-info">
                                üîµ Medium: <strong>{summary.counts.medium}</strong>
                              </span>
                            )}
                          </div>
                        )}
                        
                        <div className="mt-2 d-flex flex-wrap gap-2">
                          {scan.results.map((result) => (
                            <Badge
                              bg={result.status === 'completed' ? 'success' : 'warning'}
                              key={`${scan._id}-${result.tool}`}
                            >
                              {TOOL_DEFINITIONS[result.tool]?.label || result.tool}
                              {result.findings && result.findings.length > 0 && (
                                <span className="ms-1">({result.findings.length})</span>
                              )}
                            </Badge>
                          ))}
                        </div>
                      </div>
                      <div className="d-flex align-items-center gap-2">
                        <Button as={Link} to={`/scans/${scan._id}`} variant="primary">
                          View Details
                        </Button>
                        <Dropdown>
                          <Dropdown.Toggle variant="outline-secondary" id={`export-${scan._id}`}>
                            Export
                          </Dropdown.Toggle>
                          <Dropdown.Menu>
                            <Dropdown.Item onClick={() => handleExport(scan._id, 'json')}>
                              JSON
                            </Dropdown.Item>
                            <Dropdown.Item onClick={() => handleExport(scan._id, 'txt')}>
                              Text
                            </Dropdown.Item>
                            <Dropdown.Item onClick={() => handleExport(scan._id, 'pdf')}>
                              PDF Report
                            </Dropdown.Item>
                          </Dropdown.Menu>
                        </Dropdown>
                      </div>
                    </div>
                  </Card.Body>
                </Card>
              </Col>
            );
          })}
        </Row>
      )}
    </Stack>
  );
};

export default ScanHistoryPage;




################################################################################
## FILE 35: SubscriptionPage.jsx
## Path: client/src/pages/SubscriptionPage.jsx
################################################################################

import { useState, useEffect } from 'react';
import { Container, Row, Col, Card, Button, Badge, Alert, Spinner, ProgressBar } from 'react-bootstrap';
import { apiRequest } from '../services/apiClient';
import { useAuth } from '../context/AuthContext';
import { FaCheck, FaCrown, FaStar, FaRocket, FaInfinity } from 'react-icons/fa';

const SubscriptionPage = () => {
  const { user, token } = useAuth();
  const [plans, setPlans] = useState([]);
  const [status, setStatus] = useState(null);
  const [loading, setLoading] = useState(true);
  const [upgrading, setUpgrading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  useEffect(() => {
    fetchData();
  }, []);

  const fetchData = async () => {
    try {
      setLoading(true);
      const [plansRes, statusRes] = await Promise.all([
        apiRequest('/subscription/plans'),
        apiRequest('/subscription/status', { token })
      ]);
      setPlans(plansRes.plans || []);
      setStatus(statusRes);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  const handleUpgrade = async (planId) => {
    try {
      setUpgrading(true);
      setError('');
      setSuccess('');

      // In production, integrate with Stripe or another payment provider
      await apiRequest('/subscription/upgrade', {
        method: 'POST',
        body: { plan: planId, autoRenew: true },
        token
      });

      setSuccess(`Successfully upgraded to ${planId.toUpperCase()} plan!`);
      fetchData();
    } catch (err) {
      setError(err.message);
    } finally {
      setUpgrading(false);
    }
  };

  const handleCancel = async () => {
    if (!window.confirm('Are you sure you want to cancel your subscription?')) return;

    try {
      setUpgrading(true);
      setError('');
      await apiRequest('/subscription/cancel', {
        method: 'POST',
        token
      });
      setSuccess('Subscription cancelled. You will retain access until the end of your billing period.');
      fetchData();
    } catch (err) {
      setError(err.message);
    } finally {
      setUpgrading(false);
    }
  };

  const getPlanIcon = (planId) => {
    switch (planId) {
      case 'vip': return <FaCrown className="text-warning" />;
      case 'pro': return <FaStar className="text-primary" />;
      default: return <FaRocket className="text-secondary" />;
    }
  };

  const getPlanBadge = (planId) => {
    if (planId === 'vip') return <Badge bg="warning" text="dark">Most Popular</Badge>;
    if (planId === 'pro') return <Badge bg="primary">Best Value</Badge>;
    return null;
  };

  if (loading) {
    return (
      <Container className="py-5 text-center">
        <Spinner animation="border" role="status">
          <span className="visually-hidden">Loading...</span>
        </Spinner>
      </Container>
    );
  }

  return (
    <Container className="py-4">
      <h1 className="mb-4">Subscription Plans</h1>

      {error && <Alert variant="danger" dismissible onClose={() => setError('')}>{error}</Alert>}
      {success && <Alert variant="success" dismissible onClose={() => setSuccess('')}>{success}</Alert>}

      {/* Current Status Card */}
      {status && (
        <Card className="mb-4 border-primary">
          <Card.Header className="bg-primary text-white">
            <h5 className="mb-0">Current Subscription</h5>
          </Card.Header>
          <Card.Body>
            <Row>
              <Col md={4}>
                <div className="mb-3">
                  <strong>Plan:</strong>{' '}
                  <span className="fs-5">
                    {getPlanIcon(status.plan?.id)} {status.plan?.name}
                  </span>
                </div>
                <div>
                  <strong>Status:</strong>{' '}
                  <Badge bg={status.status === 'active' ? 'success' : 'warning'}>
                    {status.status}
                  </Badge>
                </div>
              </Col>
              <Col md={4}>
                <div className="mb-2">
                  <strong>Scans This Month:</strong>
                  {status.usage?.scansLimit === -1 ? (
                    <span className="ms-2"><FaInfinity /> Unlimited</span>
                  ) : (
                    <>
                      <div className="d-flex align-items-center mt-1">
                        <ProgressBar 
                          now={(status.usage?.scansThisMonth / status.usage?.scansLimit) * 100} 
                          className="flex-grow-1 me-2"
                          variant={status.usage?.scansThisMonth >= status.usage?.scansLimit ? 'danger' : 'primary'}
                        />
                        <span>{status.usage?.scansThisMonth}/{status.usage?.scansLimit}</span>
                      </div>
                    </>
                  )}
                </div>
              </Col>
              <Col md={4}>
                <div className="mb-2">
                  <strong>Code Reviews Today:</strong>
                  {status.usage?.codeReviewsLimit === -1 ? (
                    <span className="ms-2"><FaInfinity /> Unlimited</span>
                  ) : (
                    <>
                      <div className="d-flex align-items-center mt-1">
                        <ProgressBar 
                          now={(status.usage?.codeReviewsToday / status.usage?.codeReviewsLimit) * 100} 
                          className="flex-grow-1 me-2"
                          variant={status.usage?.codeReviewsToday >= status.usage?.codeReviewsLimit ? 'danger' : 'success'}
                        />
                        <span>{status.usage?.codeReviewsToday}/{status.usage?.codeReviewsLimit}</span>
                      </div>
                    </>
                  )}
                </div>
              </Col>
            </Row>
          </Card.Body>
        </Card>
      )}

      {/* Plans Grid */}
      <Row>
        {plans.map((plan) => (
          <Col md={4} key={plan.id} className="mb-4">
            <Card 
              className={`h-100 ${plan.id === 'vip' ? 'border-warning' : plan.id === 'pro' ? 'border-primary' : ''}`}
              style={{ borderWidth: plan.id !== 'free' ? '2px' : '1px' }}
            >
              <Card.Header className={`text-center py-3 ${
                plan.id === 'vip' ? 'bg-warning text-dark' : 
                plan.id === 'pro' ? 'bg-primary text-white' : 'bg-light'
              }`}>
                <div className="mb-2">{getPlanBadge(plan.id)}</div>
                <h3 className="mb-0">{getPlanIcon(plan.id)} {plan.name}</h3>
              </Card.Header>
              <Card.Body className="d-flex flex-column">
                <div className="text-center mb-4">
                  <span className="display-4">${plan.price}</span>
                  <span className="text-muted">/month</span>
                </div>

                <ul className="list-unstyled flex-grow-1">
                  <li className="mb-2">
                    <FaCheck className="text-success me-2" />
                    {plan.scansPerMonth === -1 ? 'Unlimited scans' : `${plan.scansPerMonth} scans/month`}
                  </li>
                  <li className="mb-2">
                    <FaCheck className="text-success me-2" />
                    {plan.codeReviewsPerDay === -1 ? 'Unlimited code reviews' : `${plan.codeReviewsPerDay} code reviews/day`}
                  </li>
                  <li className="mb-2">
                    <FaCheck className="text-success me-2" />
                    {plan.toolsAvailable?.length} security tools
                  </li>
                  {plan.features?.map((feature, idx) => (
                    <li key={idx} className="mb-2">
                      <FaCheck className="text-success me-2" />
                      {feature}
                    </li>
                  ))}
                </ul>

                <div className="mt-auto">
                  {status?.plan?.id === plan.id ? (
                    <Button variant="secondary" disabled className="w-100">
                      Current Plan
                    </Button>
                  ) : (
                    <Button
                      variant={plan.id === 'vip' ? 'warning' : plan.id === 'pro' ? 'primary' : 'outline-secondary'}
                      className="w-100"
                      onClick={() => handleUpgrade(plan.id)}
                      disabled={upgrading}
                    >
                      {upgrading ? (
                        <Spinner animation="border" size="sm" />
                      ) : status?.plan?.id === 'free' ? (
                        plan.id === 'free' ? 'Current Plan' : 'Upgrade'
                      ) : (
                        plan.price > (status?.plan?.price || 0) ? 'Upgrade' : 'Downgrade'
                      )}
                    </Button>
                  )}
                </div>
              </Card.Body>
            </Card>
          </Col>
        ))}
      </Row>

      {/* Cancel Subscription */}
      {status?.plan?.id !== 'free' && status?.status === 'active' && (
        <div className="text-center mt-4">
          <Button variant="outline-danger" onClick={handleCancel} disabled={upgrading}>
            Cancel Subscription
          </Button>
        </div>
      )}
    </Container>
  );
};

export default SubscriptionPage;




################################################################################
## FILE 36: apiClient.js
## Path: client/src/services/apiClient.js
################################################################################

import { API_BASE_URL } from '../config';

const buildHeaders = (token, customHeaders = {}) => {
  const headers = {
    'Content-Type': 'application/json',
    ...customHeaders,
  };

  if (token) {
    headers.Authorization = `Bearer ${token}`;
  }

  return headers;
};

const parseResponse = async (response) => {
  const contentType = response.headers.get('content-type');
  if (contentType && contentType.includes('application/json')) {
    return response.json();
  }

  const text = await response.text();
  return text ? { message: text } : {};
};

export const apiRequest = async (path, { method = 'GET', body, token, headers = {}, responseType } = {}) => {
  const url = path.startsWith('http') ? path : `${API_BASE_URL}${path}`;

  const requestInit = {
    method,
    headers: buildHeaders(token, headers),
    credentials: 'include',
  };

  if (body !== undefined) {
    requestInit.body = typeof body === 'string' ? body : JSON.stringify(body);
  }

  const response = await fetch(url, requestInit);

  if (!response.ok) {
    const errorPayload = await parseResponse(response);
    const error = new Error(errorPayload.message || 'Request failed');
    error.status = response.status;
    error.payload = errorPayload;
    throw error;
  }

  if (responseType === 'blob') {
    return response.blob();
  }

  if (responseType === 'text') {
    return response.text();
  }

  return parseResponse(response);
};




################################################################################
## FILE 37: tailwind.config.js
## Path: client/tailwind.config.js
################################################################################

/** @type {import('tailwindcss').Config} */
export default {
  content: ['./index.html', './src/**/*.{js,jsx,ts,tsx}'],
  theme: {
    extend: {
      colors: {
        primary: '#0d6efd',
        dark: '#0b132b',
      },
    },
  },
  plugins: [],
};





################################################################################
## FILE 38: vite.config.js
## Path: client/vite.config.js
################################################################################

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})




################################################################################
## FILE 39: package-lock.json
## Path: package-lock.json
################################################################################

[File t·ªìn t·∫°i ‚Äì kh√¥ng ƒë·ªçc n·ªôi dung theo c·∫•u h√¨nh]



################################################################################
## FILE 40: package.json
## Path: package.json
################################################################################

[File t·ªìn t·∫°i ‚Äì kh√¥ng ƒë·ªçc n·ªôi dung theo c·∫•u h√¨nh]



################################################################################
## FILE 41: .dockerignore
## Path: server/.dockerignore
################################################################################

[File t·ªìn t·∫°i ‚Äì kh√¥ng ƒë·ªçc n·ªôi dung theo c·∫•u h√¨nh]



################################################################################
## FILE 42: .env
## Path: server/.env
################################################################################

PORT=5000
MONGODB_URI=mongodb://localhost:27017/reconweb
JWT_SECRET=replace-with-secure-random-string
CLIENT_ORIGIN=http://localhost:5173




################################################################################
## FILE 43: .env.example
## Path: server/.env.example
################################################################################

# Server Configuration
PORT=5000
NODE_ENV=development

# MongoDB Connection
MONGODB_URI=mongodb://localhost:27017/reconweb

# JWT Secret (generate a secure random string)
JWT_SECRET=replace-with-secure-random-string-min-32-chars

# CORS - Client Origin (for local dev)
CLIENT_ORIGIN=http://localhost:5173

# Optional: AI API Key for code review (if using AI features)
# GEMINI_API_KEY=your-gemini-api-key
# DEEPSEEK_API_KEY=your-deepseek-api-key




################################################################################
## FILE 44: package-lock.json
## Path: server/package-lock.json
################################################################################

[File t·ªìn t·∫°i ‚Äì kh√¥ng ƒë·ªçc n·ªôi dung theo c·∫•u h√¨nh]



################################################################################
## FILE 45: package.json
## Path: server/package.json
################################################################################

[File t·ªìn t·∫°i ‚Äì kh√¥ng ƒë·ªçc n·ªôi dung theo c·∫•u h√¨nh]



################################################################################
## FILE 46: db.js
## Path: server/src/config/db.js
################################################################################

const mongoose = require('mongoose');

const connectDB = async (mongoUri) => {
  if (!mongoUri) {
    throw new Error('Missing MONGODB_URI environment variable.');
  }

  mongoose.set('strictQuery', true);

  await mongoose.connect(mongoUri, {
    serverSelectionTimeoutMS: 5000,
  });

  console.log('MongoDB connected');
};

module.exports = connectDB;




################################################################################
## FILE 47: authController.js
## Path: server/src/controllers/authController.js
################################################################################

const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { validationResult } = require('express-validator');
const User = require('../models/User');

const buildToken = (userId) => {
  const secret = process.env.JWT_SECRET;
  if (!secret) {
    throw new Error('JWT_SECRET environment variable is not configured');
  }

  return jwt.sign({ sub: userId }, secret, { expiresIn: '7d' });
};

const register = async (req, res, next) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { name, email, password } = req.body;

    const existingUser = await User.findOne({ email: email.toLowerCase() });
    if (existingUser) {
      return res.status(409).json({ message: 'Email already registered' });
    }

    const hashedPassword = await bcrypt.hash(password, 12);
    const user = await User.create({ name, email: email.toLowerCase(), password: hashedPassword });

    const token = buildToken(user.id);

    res.status(201).json({
      user: user.toSafeObject(),
      token,
    });
  } catch (error) {
    next(error);
  }
};

const login = async (req, res, next) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { email, password } = req.body;

    const user = await User.findOne({ email: email.toLowerCase() });
    if (!user) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }

    const isValidPassword = await bcrypt.compare(password, user.password);
    if (!isValidPassword) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }

    const token = buildToken(user.id);

    res.json({
      user: user.toSafeObject(),
      token,
    });
  } catch (error) {
    next(error);
  }
};

const me = async (req, res, next) => {
  try {
    const user = await User.findById(req.user.id);
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    res.json({ user: user.toSafeObject() });
  } catch (error) {
    next(error);
  }
};

module.exports = {
  register,
  login,
  me,
};




################################################################################
## FILE 48: scanController.js
## Path: server/src/controllers/scanController.js
################################################################################

const { validationResult } = require('express-validator');
const Scan = require('../models/Scan');
const scanService = require('../services/scanService');
const { generateScanPDF } = require('../services/pdfGenerator');
const subscriptionService = require('../services/subscriptionService');

const createScan = async (req, res, next) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { url, tools = [], notes } = req.body;

    // Check subscription limits
    const canScan = await subscriptionService.canPerformScan(req.user.id);
    if (!canScan.allowed) {
      return res.status(403).json({ message: canScan.reason });
    }

    // Check if all requested tools are available for user's plan
    for (const tool of tools) {
      const toolName = typeof tool.tool === 'string' ? tool.tool.toLowerCase() : '';
      const isAvailable = await subscriptionService.isToolAvailable(req.user.id, toolName);
      if (!isAvailable) {
        return res.status(403).json({ 
          message: `Tool "${toolName}" is not available in your current plan. Please upgrade to access this tool.` 
        });
      }
    }

    const sanitizedUrl = url.trim();

    // T·∫°o scan v·ªõi status pending
    const scan = await Scan.create({
      user: req.user.id,
      targetUrl: sanitizedUrl,
      notes: notes || '',
      status: 'pending',
      progress: 0,
      results: tools.map(t => ({
        tool: typeof t.tool === 'string' ? t.tool.toLowerCase() : '',
        status: 'pending',
        options: t.options || {}
      }))
    });

    // Increment scan count
    await subscriptionService.incrementScanCount(req.user.id);

    // Tr·∫£ v·ªÅ scan ID ngay l·∫≠p t·ª©c
    res.status(201).json(scan);

    // Ch·∫°y scan trong background
    scanService.runScanBatchAsync(scan._id, sanitizedUrl, tools).catch(err => {
      console.error('Background scan error:', err);
    });

  } catch (error) {
    next(error);
  }
};

const listScans = async (req, res, next) => {
  try {
    const scans = await Scan.find({ user: req.user.id })
      .sort({ createdAt: -1 })
      .lean();

    res.json({ scans });
  } catch (error) {
    next(error);
  }
};

const getScanById = async (req, res, next) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const scan = await Scan.findOne({ _id: req.params.id, user: req.user.id }).lean();

    if (!scan) {
      return res.status(404).json({ message: 'Scan not found' });
    }

    res.json({ scan });
  } catch (error) {
    next(error);
  }
};

const exportScan = async (req, res, next) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const scan = await Scan.findOne({ _id: req.params.id, user: req.user.id }).lean();

    if (!scan) {
      return res.status(404).json({ message: 'Scan not found' });
    }

    const format = (req.query.format || 'json').toLowerCase();

    if (format === 'json') {
      res.setHeader('Content-Type', 'application/json');
      res.setHeader('Content-Disposition', `attachment; filename=scan-${scan._id}.json`);
      return res.send(JSON.stringify(scan, null, 2));
    }

    if (format === 'pdf') {
      return generateScanPDF(scan, res);
    }

    if (format === 'txt') {
      const lines = [];
      lines.push(`Scan ID: ${scan._id}`);
      lines.push(`Target URL: ${scan.targetUrl}`);
      lines.push(`Created At: ${scan.createdAt}`);
      lines.push('');
      scan.results.forEach((result) => {
        lines.push(`Tool: ${result.tool}`);
        lines.push(`Status: ${result.status}`);
        lines.push(`Started: ${result.startedAt || 'N/A'}`);
        lines.push(`Finished: ${result.finishedAt || 'N/A'}`);
        lines.push('Options:');
        lines.push(JSON.stringify(result.options, null, 2));
        lines.push('Output:');
        lines.push(result.output || '');
        if (result.error) {
          lines.push('Error:');
          lines.push(result.error);
        }
        lines.push('');
        lines.push('---');
        lines.push('');
      });
      const payload = lines.join('\n');
      res.setHeader('Content-Type', 'text/plain');
      res.setHeader('Content-Disposition', `attachment; filename=scan-${scan._id}.txt`);
      return res.send(payload);
    }

    return res.status(400).json({ message: 'Unsupported export format' });
  } catch (error) {
    next(error);
  }
};

module.exports = {
  createScan,
  listScans,
  getScanById,
  exportScan,
};




################################################################################
## FILE 49: index.js
## Path: server/src/index.js
################################################################################

require('dotenv').config();
const express = require('express');
const cors = require('cors');
const cookieParser = require('cookie-parser');
const connectDB = require('./config/db');
const authRoutes = require('./routes/authRoutes');
const scanRoutes = require('./routes/scanRoutes');
const subscriptionRoutes = require('./routes/subscriptionRoutes');
const codeReviewRoutes = require('./routes/codeReviewRoutes');
const remediationRoutes = require('./routes/remediationRoutes');

const app = express();

const allowedOrigins = process.env.CLIENT_ORIGIN
  ? process.env.CLIENT_ORIGIN.split(',').map((origin) => origin.trim())
  : ['http://localhost:5173'];

app.use(
  cors({
    origin: allowedOrigins,
    credentials: true,
  })
);
app.use(express.json({ limit: '2mb' }));
app.use(cookieParser());

app.get('/api/health', (_req, res) => {
  res.json({ status: 'ok' });
});

app.use('/api/auth', authRoutes);
app.use('/api/scans', scanRoutes);
app.use('/api/subscription', subscriptionRoutes);
app.use('/api/code-review', codeReviewRoutes);
app.use('/api/remediation', remediationRoutes);

app.use((err, _req, res, _next) => {
  // Fallback error handler to avoid leaking implementation details
  const status = err.status || 500;
  const message = err.message || 'Internal server error';
  res.status(status).json({ message });
});

const PORT = process.env.PORT || 5000;

const bootstrap = async () => {
  try {
    await connectDB(process.env.MONGODB_URI);
    app.listen(PORT, () => {
      console.log(`Server listening on port ${PORT}`);
    });
  } catch (error) {
    console.error('Failed to start server', error);
    process.exit(1);
  }
};

bootstrap();




################################################################################
## FILE 50: authMiddleware.js
## Path: server/src/middleware/authMiddleware.js
################################################################################

const jwt = require('jsonwebtoken');

const extractToken = (req) => {
  const authHeader = req.headers.authorization || '';
  if (authHeader.startsWith('Bearer ')) {
    return authHeader.slice(7).trim();
  }

  if (req.cookies && req.cookies.token) {
    return req.cookies.token;
  }

  return null;
};

module.exports = (req, res, next) => {
  try {
    const token = extractToken(req);

    if (!token) {
      return res.status(401).json({ message: 'Authentication token missing' });
    }

    const secret = process.env.JWT_SECRET;
    if (!secret) {
      throw new Error('JWT_SECRET environment variable is not configured');
    }

    const payload = jwt.verify(token, secret);

    req.user = { id: payload.sub };

    next();
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({ message: 'Token expired' });
    }

    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({ message: 'Invalid token' });
    }

    next(error);
  }
};




################################################################################
## FILE 51: CodeReview.js
## Path: server/src/models/CodeReview.js
################################################################################

const mongoose = require('mongoose');

const vulnerabilitySchema = new mongoose.Schema({
  type: {
    type: String,
    required: true
  },
  severity: {
    type: String,
    enum: ['critical', 'high', 'medium', 'low', 'info'],
    required: true
  },
  line: Number,
  cwe: String, // CWE reference (e.g., "CWE-89")
  owasp: String, // OWASP Top 10 reference (e.g., "A03:2021")
  description: String,
  recommendation: String,
  matchedCode: String, // The code pattern that matched
  codeContext: String, // The line of code for context
  example: { // Secure coding example
    vulnerable: String,
    secure: String
  },
  fixedCode: String
}, { _id: false });

const owaspIssueSchema = new mongoose.Schema({
  code: String, // e.g., "A03:2021"
  name: String, // e.g., "Injection"
  issueCount: Number,
  issues: [{
    type: String,
    severity: String,
    line: Number,
    cwe: String
  }]
}, { _id: false });

const codeReviewSchema = new mongoose.Schema({
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  language: {
    type: String,
    required: true,
    enum: ['javascript', 'typescript', 'python', 'java', 'php', 'csharp', 'go', 'ruby', 'sql', 'html', 'other']
  },
  codeSnippet: {
    type: String,
    required: true,
    maxlength: 50000
  },
  title: {
    type: String,
    default: 'Untitled Review'
  },
  status: {
    type: String,
    enum: ['pending', 'processing', 'completed', 'failed'],
    default: 'pending'
  },
  vulnerabilities: [vulnerabilitySchema],
  overallRisk: {
    type: String,
    enum: ['secure', 'low', 'medium', 'high', 'critical'],
    default: 'secure'
  },
  summary: String,
  owaspCompliance: [owaspIssueSchema], // OWASP Top 10 compliance report
  analysisMetadata: {
    patternsChecked: Number,
    languagePatternsChecked: Number,
    linesAnalyzed: Number,
    analysisVersion: String
  },
  aiResponse: {
    type: Object,
    default: null
  },
  processingTime: Number,
  error: String
}, {
  timestamps: true
});

// Index for user queries
codeReviewSchema.index({ user: 1, createdAt: -1 });
codeReviewSchema.index({ 'vulnerabilities.severity': 1 });
codeReviewSchema.index({ overallRisk: 1 });

module.exports = mongoose.model('CodeReview', codeReviewSchema);




################################################################################
## FILE 52: Scan.js
## Path: server/src/models/Scan.js
################################################################################

const mongoose = require('mongoose');

const scanResultSchema = new mongoose.Schema(
  {
    tool: {
      type: String,
      required: true,
      enum: ['nikto', 'gobuster', 'nuclei', 'sqlmap', 'xsstrike', 'wpscan'],
    },
    status: {
      type: String,
      enum: ['pending', 'running', 'completed', 'failed'],
      default: 'pending',
    },
    options: {
      type: Object,
      default: {},
    },
    output: {
      type: String,
      default: '',
    },
    error: {
      type: String,
      default: '',
    },
    findings: {
      type: Array,
      default: [],
    },
    startedAt: Date,
    finishedAt: Date,
  },
  {
    _id: false,
  }
);

const scanSchema = new mongoose.Schema(
  {
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
    targetUrl: {
      type: String,
      required: true,
      trim: true,
    },
    notes: {
      type: String,
      default: '',
      maxlength: 500,
    },
    status: {
      type: String,
      enum: ['pending', 'running', 'completed', 'failed'],
      default: 'pending',
    },
    progress: {
      type: Number,
      default: 0,
      min: 0,
      max: 100,
    },
    results: [scanResultSchema],
    summary: {
      type: Object,
      default: null,
    },
  },
  {
    timestamps: true,
  }
);

module.exports = mongoose.model('Scan', scanSchema);




################################################################################
## FILE 53: User.js
## Path: server/src/models/User.js
################################################################################

const mongoose = require('mongoose');

const subscriptionSchema = new mongoose.Schema({
  plan: {
    type: String,
    enum: ['free', 'vip_monthly', 'vip_annual'],
    default: 'free'
  },
  status: {
    type: String,
    enum: ['active', 'expired', 'cancelled'],
    default: 'active'
  },
  startDate: Date,
  expiresAt: Date,
  autoRenew: {
    type: Boolean,
    default: true
  }
}, { _id: false });

const usageSchema = new mongoose.Schema({
  scansThisMonth: { type: Number, default: 0 },
  codeReviewsToday: { type: Number, default: 0 },
  lastScanReset: { type: Date, default: Date.now },
  lastReviewReset: { type: Date, default: Date.now }
}, { _id: false });

const userSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: true,
      trim: true,
      maxlength: 120,
    },
    email: {
      type: String,
      required: true,
      unique: true,
      lowercase: true,
      trim: true,
      maxlength: 180,
    },
    password: {
      type: String,
      required: true,
    },
    subscription: {
      type: subscriptionSchema,
      default: () => ({ plan: 'free', status: 'active' })
    },
    usage: {
      type: usageSchema,
      default: () => ({})
    }
  },
  {
    timestamps: true,
  }
);

userSchema.methods.toSafeObject = function toSafeObject() {
  const obj = this.toObject();
  delete obj.password;
  return obj;
};

module.exports = mongoose.model('User', userSchema);




################################################################################
## FILE 54: authRoutes.js
## Path: server/src/routes/authRoutes.js
################################################################################

const { Router } = require('express');
const { body } = require('express-validator');
const authController = require('../controllers/authController');
const authMiddleware = require('../middleware/authMiddleware');

const router = Router();

router.post(
  '/register',
  [
    body('name').trim().isLength({ min: 2 }).withMessage('Name must be at least 2 characters'),
    body('email').isEmail().withMessage('Invalid email address').normalizeEmail(),
    body('password')
      .isLength({ min: 8 })
      .withMessage('Password must be at least 8 characters')
      .matches(/[a-z]/i)
      .withMessage('Password must contain a letter')
      .matches(/[0-9]/)
      .withMessage('Password must contain a number'),
  ],
  authController.register
);

router.post(
  '/login',
  [
    body('email').isEmail().withMessage('Invalid email address').normalizeEmail(),
    body('password').notEmpty().withMessage('Password is required'),
  ],
  authController.login
);

router.get('/me', authMiddleware, authController.me);

module.exports = router;




################################################################################
## FILE 55: codeReviewRoutes.js
## Path: server/src/routes/codeReviewRoutes.js
################################################################################

const express = require('express');
const router = express.Router();
const protect = require('../middleware/authMiddleware');
const codeReviewService = require('../services/codeReviewService');

// Submit code for security review
router.post('/review', protect, async (req, res) => {
  try {
    const { code, language, title } = req.body;
    
    if (!code) {
      return res.status(400).json({ message: 'Code is required' });
    }
    
    if (!language) {
      return res.status(400).json({ message: 'Language is required' });
    }

    if (code.length > 50000) {
      return res.status(400).json({ message: 'Code exceeds maximum length (50,000 characters)' });
    }

    const review = await codeReviewService.reviewCode(
      req.user.id, 
      code, 
      language, 
      title
    );

    res.status(201).json(review);
  } catch (error) {
    console.error('Code review error:', error);
    res.status(400).json({ message: error.message });
  }
});

// Get code review history
router.get('/history', protect, async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;

    const result = await codeReviewService.getReviewHistory(req.user.id, page, limit);
    res.json(result);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Get review statistics
router.get('/stats', protect, async (req, res) => {
  try {
    const stats = await codeReviewService.getReviewStats(req.user.id);
    res.json(stats);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Get specific code review
router.get('/:id', protect, async (req, res) => {
  try {
    const review = await codeReviewService.getReviewById(req.user.id, req.params.id);
    res.json(review);
  } catch (error) {
    res.status(404).json({ message: error.message });
  }
});

// Delete a code review
router.delete('/:id', protect, async (req, res) => {
  try {
    await codeReviewService.deleteReview(req.user.id, req.params.id);
    res.json({ message: 'Review deleted successfully' });
  } catch (error) {
    res.status(404).json({ message: error.message });
  }
});

module.exports = router;




################################################################################
## FILE 56: remediationRoutes.js
## Path: server/src/routes/remediationRoutes.js
################################################################################

const express = require('express');
const router = express.Router();
const protect = require('../middleware/authMiddleware');
const remediationService = require('../services/remediationService');
const Scan = require('../models/Scan');

// Get AI-powered remediation for a scan (VIP only)
router.get('/scan/:scanId', protect, async (req, res) => {
  try {
    const scan = await Scan.findOne({ _id: req.params.scanId, user: req.user.id });
    
    if (!scan) {
      return res.status(404).json({ message: 'Scan not found' });
    }

    if (!scan.findings || scan.findings.length === 0) {
      return res.json({
        message: 'No findings to remediate',
        scanId: scan._id,
        targetUrl: scan.targetUrl
      });
    }

    const remediation = await remediationService.generateRemediation(
      req.user.id,
      scan._id,
      scan.findings,
      scan.targetUrl
    );

    res.json(remediation);
  } catch (error) {
    const statusCode = error.message.includes('VIP plan') ? 403 : 500;
    res.status(statusCode).json({ message: error.message });
  }
});

// Get basic remediation for a scan (available for all plans)
router.get('/basic/:scanId', protect, async (req, res) => {
  try {
    const scan = await Scan.findOne({ _id: req.params.scanId, user: req.user.id });
    
    if (!scan) {
      return res.status(404).json({ message: 'Scan not found' });
    }

    const remediation = remediationService.getBasicRemediationForFindings(scan.findings);
    
    res.json({
      scanId: scan._id,
      targetUrl: scan.targetUrl,
      ...remediation
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Get quick tips by severity
router.get('/tips/:severity', (req, res) => {
  const { severity } = req.params;
  const validSeverities = ['critical', 'high', 'medium', 'low'];
  
  if (!validSeverities.includes(severity.toLowerCase())) {
    return res.status(400).json({ message: 'Invalid severity level' });
  }

  const tips = remediationService.getQuickTips(severity.toLowerCase());
  res.json({ severity, tips });
});

module.exports = router;




################################################################################
## FILE 57: scanRoutes.js
## Path: server/src/routes/scanRoutes.js
################################################################################

const { Router } = require('express');
const { body, param, query } = require('express-validator');
const authMiddleware = require('../middleware/authMiddleware');
const scanController = require('../controllers/scanController');
const scanService = require('../services/scanService');

const router = Router();

const supportedTools = scanService.getSupportedTools();

// API ƒë·ªÉ l·∫•y danh s√°ch tool ƒë√£ c√†i ƒë·∫∑t (kh√¥ng c·∫ßn auth)
router.get('/tools/installed', (req, res) => {
  const installed = scanService.getInstalledTools();
  const all = scanService.getSupportedTools();
  res.json({
    installed,
    all,
    notInstalled: all.filter(t => !installed.includes(t))
  });
});

router.use(authMiddleware);

router.post(
  '/',
  [
    body('url').isURL({ require_protocol: true }).withMessage('A valid URL with protocol is required'),
    body('notes').optional().isString().isLength({ max: 500 }).withMessage('Notes must be 500 characters or less'),
    body('tools').isArray({ min: 1 }).withMessage('At least one tool must be selected'),
    body('tools.*.tool')
      .isIn(supportedTools)
      .withMessage(`Tool must be one of: ${supportedTools.join(', ')}`),
    body('tools.*.options').optional().isObject().withMessage('Options must be an object'),
  ],
  scanController.createScan
);

router.get('/', scanController.listScans);

router.get(
  '/:id',
  [param('id').isMongoId().withMessage('Invalid scan id')],
  scanController.getScanById
);

router.get(
  '/:id/export',
  [
    param('id').isMongoId().withMessage('Invalid scan id'),
    query('format').optional().isIn(['json', 'txt']).withMessage('Format must be json or txt'),
  ],
  scanController.exportScan
);

module.exports = router;




################################################################################
## FILE 58: subscriptionRoutes.js
## Path: server/src/routes/subscriptionRoutes.js
################################################################################

const express = require('express');
const router = express.Router();
const protect = require('../middleware/authMiddleware');
const subscriptionService = require('../services/subscriptionService');

// Get all available plans
router.get('/plans', (req, res) => {
  try {
    const plans = subscriptionService.getAllPlans();
    res.json({ plans });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Get current user's subscription status
router.get('/status', protect, async (req, res) => {
  try {
    const status = await subscriptionService.getSubscriptionStatus(req.user.id);
    res.json(status);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Upgrade subscription
router.post('/upgrade', protect, async (req, res) => {
  try {
    const { plan, paymentToken, autoRenew } = req.body;
    
    if (!plan) {
      return res.status(400).json({ message: 'Plan is required' });
    }

    // In production, you would validate payment token with payment provider (Stripe, etc.)
    // For demo purposes, we'll simulate successful payment
    const paymentDetails = {
      autoRenew: autoRenew || false,
      paymentToken
    };

    const result = await subscriptionService.upgradeSubscription(
      req.user.id, 
      plan, 
      paymentDetails
    );

    res.json(result);
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
});

// Cancel subscription
router.post('/cancel', protect, async (req, res) => {
  try {
    const result = await subscriptionService.cancelSubscription(req.user.id);
    res.json(result);
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
});

// Check if user can perform a scan
router.get('/can-scan', protect, async (req, res) => {
  try {
    const result = await subscriptionService.canPerformScan(req.user.id);
    res.json(result);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Check if user can perform code review
router.get('/can-review', protect, async (req, res) => {
  try {
    const result = await subscriptionService.canPerformCodeReview(req.user.id);
    res.json(result);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Check if a tool is available for user's plan
router.get('/tool-available/:toolName', protect, async (req, res) => {
  try {
    const available = await subscriptionService.isToolAvailable(
      req.user.id, 
      req.params.toolName
    );
    res.json({ available });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

module.exports = router;




################################################################################
## FILE 59: codeReviewService.js
## Path: server/src/services/codeReviewService.js
################################################################################

const CodeReview = require('../models/CodeReview');
const subscriptionService = require('./subscriptionService');

/**
 * OWASP-based Security Patterns for Code Review
 * Reference: OWASP Code Review Guide, OWASP Top 10, OWASP Cheat Sheet Series
 * Each pattern includes CWE (Common Weakness Enumeration) references
 */
const SECURITY_PATTERNS = {
  // ===========================================
  // A03:2021 - INJECTION
  // ===========================================
  sql_injection: [
    { 
      pattern: /(\$\{.*\}|"\s*\+\s*\w+|\'\s*\+\s*\w+).*(?:SELECT|INSERT|UPDATE|DELETE|FROM|WHERE|DROP|UNION|TRUNCATE|ALTER|CREATE|EXEC)/gi,
      severity: 'critical',
      cwe: 'CWE-89',
      owasp: 'A03:2021',
      description: 'SQL Injection: User input concatenated into SQL query without parameterization.',
      recommendation: 'Use parameterized queries or prepared statements. Never concatenate user input into SQL.',
      example: {
        vulnerable: 'query("SELECT * FROM users WHERE id = " + userId)',
        secure: 'query("SELECT * FROM users WHERE id = ?", [userId])'
      }
    },
    {
      pattern: /execute\s*\(\s*["'`].*\$|query\s*\(\s*["'`].*\+|raw\s*\(\s*["'`].*\$/gi,
      severity: 'critical',
      cwe: 'CWE-89',
      owasp: 'A03:2021',
      description: 'Raw SQL query with string interpolation detected.',
      recommendation: 'Use ORM methods with parameter binding or prepared statements.'
    },
    {
      pattern: /cursor\.execute\s*\(\s*f["']|cursor\.execute\s*\(\s*["'].*%|\.format\s*\(.*\).*(?:SELECT|INSERT|UPDATE|DELETE)/gi,
      severity: 'critical',
      cwe: 'CWE-89',
      owasp: 'A03:2021',
      description: 'Python SQL query with f-string or format string - SQL injection risk.',
      recommendation: 'Use parameterized queries: cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))'
    },
    {
      pattern: /StringBuffer|StringBuilder.*(?:SELECT|INSERT|UPDATE|DELETE|FROM|WHERE)/gi,
      severity: 'high',
      cwe: 'CWE-89',
      owasp: 'A03:2021',
      description: 'Java SQL query built with StringBuffer/StringBuilder.',
      recommendation: 'Use PreparedStatement with parameter binding.'
    },
    {
      pattern: /\$wpdb->query\s*\(\s*["'].*\$/gi,
      severity: 'critical',
      cwe: 'CWE-89',
      owasp: 'A03:2021',
      description: 'WordPress direct query with variable injection.',
      recommendation: 'Use $wpdb->prepare() for parameterized queries.'
    }
  ],

  nosql_injection: [
    {
      pattern: /\$where|\.find\s*\(\s*\{.*\$|\.aggregate\s*\(\s*\[.*\$/gi,
      severity: 'high',
      cwe: 'CWE-943',
      owasp: 'A03:2021',
      description: 'NoSQL injection risk: Query operators from user input.',
      recommendation: 'Sanitize input and avoid $where. Use schema validation.'
    },
    {
      pattern: /JSON\.parse\s*\(.*req\.(body|query|params)/gi,
      severity: 'high',
      cwe: 'CWE-943',
      owasp: 'A03:2021',
      description: 'Parsing user input as JSON for database queries.',
      recommendation: 'Validate and sanitize parsed JSON before database operations.'
    }
  ],

  ldap_injection: [
    {
      pattern: /ldap_search.*\+|ldap_bind.*\+|\(\&\(|\(\|\(/gi,
      severity: 'high',
      cwe: 'CWE-90',
      owasp: 'A03:2021',
      description: 'LDAP injection: User input in LDAP filter.',
      recommendation: 'Escape LDAP special characters: *, (, ), \\, NUL'
    }
  ],

  xpath_injection: [
    {
      pattern: /xpath\s*\(.*\+|selectNodes\s*\(.*\+|evaluate\s*\(.*\+/gi,
      severity: 'high',
      cwe: 'CWE-643',
      owasp: 'A03:2021',
      description: 'XPath injection: User input in XPath query.',
      recommendation: 'Use parameterized XPath queries or validate input strictly.'
    }
  ],

  // ===========================================
  // A03:2021 - XSS (Cross-Site Scripting)
  // ===========================================
  xss: [
    {
      pattern: /innerHTML\s*=|outerHTML\s*=|document\.write\s*\(/gi,
      severity: 'high',
      cwe: 'CWE-79',
      owasp: 'A03:2021',
      description: 'DOM-based XSS: Direct HTML injection via innerHTML/document.write.',
      recommendation: 'Use textContent for text, or sanitize with DOMPurify before innerHTML.',
      example: {
        vulnerable: 'element.innerHTML = userInput',
        secure: 'element.textContent = userInput'
      }
    },
    {
      pattern: /dangerouslySetInnerHTML/gi,
      severity: 'high',
      cwe: 'CWE-79',
      owasp: 'A03:2021',
      description: 'React dangerouslySetInnerHTML bypasses XSS protection.',
      recommendation: 'Sanitize with DOMPurify: dangerouslySetInnerHTML={{__html: DOMPurify.sanitize(html)}}'
    },
    {
      pattern: /\$\(.*\)\.html\s*\(|\.append\s*\(.*\<|\.prepend\s*\(.*\</gi,
      severity: 'high',
      cwe: 'CWE-79',
      owasp: 'A03:2021',
      description: 'jQuery XSS: HTML injection via .html(), .append(), .prepend().',
      recommendation: 'Use .text() for text content or sanitize HTML input.'
    },
    {
      pattern: /eval\s*\(|new\s+Function\s*\(|setTimeout\s*\(\s*["'`]|setInterval\s*\(\s*["'`]/gi,
      severity: 'critical',
      cwe: 'CWE-95',
      owasp: 'A03:2021',
      description: 'Code injection: eval/Function execution with potential user input.',
      recommendation: 'Never use eval() with user data. Use JSON.parse() for data parsing.'
    },
    {
      pattern: /location\s*=|location\.href\s*=|location\.replace\s*\(/gi,
      severity: 'medium',
      cwe: 'CWE-79',
      owasp: 'A03:2021',
      description: 'DOM XSS sink: Location manipulation.',
      recommendation: 'Validate URLs against allowlist before redirect.'
    },
    {
      pattern: /v-html\s*=|ng-bind-html|{{{.*}}}/gi,
      severity: 'high',
      cwe: 'CWE-79',
      owasp: 'A03:2021',
      description: 'Vue/Angular raw HTML binding - XSS risk.',
      recommendation: 'Sanitize content before binding or use text interpolation.'
    },
    {
      pattern: /res\.send\s*\(.*req\.|res\.write\s*\(.*req\./gi,
      severity: 'high',
      cwe: 'CWE-79',
      owasp: 'A03:2021',
      description: 'Reflected XSS: User input directly in response.',
      recommendation: 'Encode output using context-appropriate encoding.'
    }
  ],

  // ===========================================
  // A03:2021 - COMMAND INJECTION
  // ===========================================
  command_injection: [
    {
      pattern: /child_process\.exec\s*\(|execSync\s*\(|spawn\s*\(.*shell\s*:\s*true/gi,
      severity: 'critical',
      cwe: 'CWE-78',
      owasp: 'A03:2021',
      description: 'OS Command Injection: Shell command with potential user input.',
      recommendation: 'Use spawn() with arguments array, never shell: true with user input.',
      example: {
        vulnerable: 'exec("ls " + userInput)',
        secure: 'spawn("ls", ["-la", sanitizedPath], {shell: false})'
      }
    },
    {
      pattern: /os\.system\s*\(|os\.popen\s*\(|subprocess\.call\s*\(.*shell\s*=\s*True/gi,
      severity: 'critical',
      cwe: 'CWE-78',
      owasp: 'A03:2021',
      description: 'Python command injection with shell execution.',
      recommendation: 'Use subprocess.run() with shell=False and argument list.'
    },
    {
      pattern: /Runtime\.getRuntime\s*\(\s*\)\.exec|ProcessBuilder/gi,
      severity: 'high',
      cwe: 'CWE-78',
      owasp: 'A03:2021',
      description: 'Java command execution detected.',
      recommendation: 'Use ProcessBuilder with argument list, validate all inputs.'
    },
    {
      pattern: /system\s*\(|passthru\s*\(|shell_exec\s*\(|popen\s*\(|proc_open\s*\(/gi,
      severity: 'critical',
      cwe: 'CWE-78',
      owasp: 'A03:2021',
      description: 'PHP command execution function.',
      recommendation: 'Use escapeshellarg() and escapeshellcmd(), or avoid shell commands.'
    },
    {
      pattern: /`.*\$|`.*\+/gi,
      severity: 'high',
      cwe: 'CWE-78',
      owasp: 'A03:2021',
      description: 'Backtick command execution with variable interpolation.',
      recommendation: 'Avoid backticks, use explicit subprocess with argument arrays.'
    }
  ],

  // ===========================================
  // A01:2021 - BROKEN ACCESS CONTROL
  // ===========================================
  path_traversal: [
    {
      pattern: /\.\.\/|\.\.\\|%2e%2e%2f|%2e%2e\/|\.\.%2f/gi,
      severity: 'high',
      cwe: 'CWE-22',
      owasp: 'A01:2021',
      description: 'Path traversal pattern detected in code.',
      recommendation: 'Use path.resolve() and verify path is within allowed directory.'
    },
    {
      pattern: /readFile\s*\(.*\+|readFileSync\s*\(.*\+|fs\..*\(.*req\./gi,
      severity: 'high',
      cwe: 'CWE-22',
      owasp: 'A01:2021',
      description: 'File operation with user-controlled path.',
      recommendation: 'Validate path: path.resolve(base, input).startsWith(base)',
      example: {
        vulnerable: 'fs.readFile(userPath)',
        secure: 'const safePath = path.resolve(baseDir, userInput);\nif (!safePath.startsWith(baseDir)) throw new Error("Invalid path");'
      }
    },
    {
      pattern: /include\s*\(\s*\$|require\s*\(\s*\$|include_once\s*\(\s*\$/gi,
      severity: 'critical',
      cwe: 'CWE-98',
      owasp: 'A01:2021',
      description: 'PHP Local/Remote File Inclusion vulnerability.',
      recommendation: 'Never use user input in include/require. Use allowlist approach.'
    },
    {
      pattern: /open\s*\(.*\+.*['"]\s*[rwa]/gi,
      severity: 'high',
      cwe: 'CWE-22',
      owasp: 'A01:2021',
      description: 'Python file open with concatenated path.',
      recommendation: 'Validate path using os.path.realpath() and check prefix.'
    }
  ],

  insecure_direct_object_reference: [
    {
      pattern: /findById\s*\(.*req\.params|findOne\s*\(\s*\{\s*_id\s*:\s*req\.params/gi,
      severity: 'medium',
      cwe: 'CWE-639',
      owasp: 'A01:2021',
      description: 'IDOR: Direct database lookup with user-supplied ID.',
      recommendation: 'Verify user has permission to access the resource.'
    },
    {
      pattern: /\.find\s*\(\s*\{\s*id\s*:\s*req\.(params|query|body)/gi,
      severity: 'medium',
      cwe: 'CWE-639',
      owasp: 'A01:2021',
      description: 'Potential IDOR vulnerability.',
      recommendation: 'Add authorization check: verify resource belongs to user.'
    }
  ],

  // ===========================================
  // A02:2021 - CRYPTOGRAPHIC FAILURES
  // ===========================================
  hardcoded_secrets: [
    {
      pattern: /(?:password|passwd|pwd|secret|api_?key|apikey|auth_?token|access_?token|private_?key)[\s]*[=:]\s*["'][^"'\s]{8,}/gi,
      severity: 'critical',
      cwe: 'CWE-798',
      owasp: 'A02:2021',
      description: 'Hardcoded credential or secret detected.',
      recommendation: 'Use environment variables or a secrets manager (AWS Secrets Manager, HashiCorp Vault).',
      example: {
        vulnerable: 'const API_KEY = "sk-1234567890abcdef"',
        secure: 'const API_KEY = process.env.API_KEY'
      }
    },
    {
      pattern: /-----BEGIN\s+(RSA\s+|EC\s+|DSA\s+|OPENSSH\s+)?PRIVATE\s+KEY-----/gi,
      severity: 'critical',
      cwe: 'CWE-321',
      owasp: 'A02:2021',
      description: 'Private key embedded in source code.',
      recommendation: 'Store private keys in secure key management system, never in code.'
    },
    {
      pattern: /(?:ghp_|gho_|github_pat_|glpat-)[a-zA-Z0-9]{20,}/gi,
      severity: 'critical',
      cwe: 'CWE-798',
      owasp: 'A02:2021',
      description: 'GitHub/GitLab access token detected.',
      recommendation: 'Revoke immediately and use environment variables.'
    },
    {
      pattern: /(?:sk-|pk_live_|sk_live_|rk_live_|sk_test_)[a-zA-Z0-9]{20,}/gi,
      severity: 'critical',
      cwe: 'CWE-798',
      owasp: 'A02:2021',
      description: 'API key detected (Stripe/OpenAI/etc).',
      recommendation: 'Rotate key immediately, use environment variables.'
    },
    {
      pattern: /AKIA[0-9A-Z]{16}/gi,
      severity: 'critical',
      cwe: 'CWE-798',
      owasp: 'A02:2021',
      description: 'AWS Access Key ID detected.',
      recommendation: 'Use IAM roles or AWS Secrets Manager.'
    },
    {
      pattern: /(?:mongodb|mysql|postgres|redis):\/\/[^:]+:[^@]+@/gi,
      severity: 'critical',
      cwe: 'CWE-798',
      owasp: 'A02:2021',
      description: 'Database connection string with credentials.',
      recommendation: 'Use environment variables for database credentials.'
    }
  ],

  insecure_crypto: [
    {
      pattern: /md5\s*\(|MD5\.|hashlib\.md5|createHash\s*\(\s*["']md5|DigestUtils\.md5/gi,
      severity: 'high',
      cwe: 'CWE-328',
      owasp: 'A02:2021',
      description: 'MD5 hash usage - cryptographically broken for security purposes.',
      recommendation: 'Use SHA-256 for integrity, bcrypt/Argon2 for passwords.'
    },
    {
      pattern: /sha1\s*\(|SHA1\.|hashlib\.sha1|createHash\s*\(\s*["']sha1|DigestUtils\.sha1/gi,
      severity: 'medium',
      cwe: 'CWE-328',
      owasp: 'A02:2021',
      description: 'SHA-1 hash usage - considered weak, collision attacks possible.',
      recommendation: 'Use SHA-256 or SHA-3 for cryptographic operations.'
    },
    {
      pattern: /DES|3DES|RC4|RC2|Blowfish|IDEA/gi,
      severity: 'high',
      cwe: 'CWE-327',
      owasp: 'A02:2021',
      description: 'Weak/deprecated encryption algorithm.',
      recommendation: 'Use AES-256-GCM or ChaCha20-Poly1305.'
    },
    {
      pattern: /ECB|AES\/ECB|Cipher\.getInstance\s*\(\s*["']AES["']\s*\)/gi,
      severity: 'high',
      cwe: 'CWE-327',
      owasp: 'A02:2021',
      description: 'ECB mode encryption - patterns can be detected.',
      recommendation: 'Use GCM or CBC mode with random IV.'
    },
    {
      pattern: /Math\.random\s*\(\)|rand\s*\(\)|random\s*\(\)/gi,
      severity: 'medium',
      cwe: 'CWE-330',
      owasp: 'A02:2021',
      description: 'Weak PRNG for security-sensitive context.',
      recommendation: 'Use crypto.randomBytes() (Node), secrets module (Python), SecureRandom (Java).'
    },
    {
      pattern: /new\s+Random\s*\(\)|Random\s*\(\s*\)/gi,
      severity: 'medium',
      cwe: 'CWE-330',
      owasp: 'A02:2021',
      description: 'Java Random class is not cryptographically secure.',
      recommendation: 'Use java.security.SecureRandom for security contexts.'
    },
    {
      pattern: /padding\s*:\s*["']PKCS5["']|PKCS5Padding/gi,
      severity: 'low',
      cwe: 'CWE-649',
      owasp: 'A02:2021',
      description: 'PKCS5 padding may be vulnerable to padding oracle attacks.',
      recommendation: 'Use authenticated encryption (GCM) which handles padding securely.'
    }
  ],

  // ===========================================
  // A07:2021 - IDENTIFICATION AND AUTH FAILURES
  // ===========================================
  auth_issues: [
    {
      pattern: /jwt\.decode\s*\((?![^)]*verify)/gi,
      severity: 'high',
      cwe: 'CWE-347',
      owasp: 'A07:2021',
      description: 'JWT decode without signature verification.',
      recommendation: 'Always use jwt.verify() to validate token signature.'
    },
    {
      pattern: /algorithm\s*[=:]\s*["']none["']|"alg"\s*:\s*"none"/gi,
      severity: 'critical',
      cwe: 'CWE-327',
      owasp: 'A07:2021',
      description: 'JWT with "none" algorithm - completely insecure.',
      recommendation: 'Always specify allowed algorithms: ["RS256", "HS256"]'
    },
    {
      pattern: /algorithms\s*:\s*\[.*["']none["']/gi,
      severity: 'critical',
      cwe: 'CWE-327',
      owasp: 'A07:2021',
      description: 'JWT verification allows "none" algorithm.',
      recommendation: 'Remove "none" from allowed algorithms list.'
    },
    {
      pattern: /password.*==|password.*===|strcmp\s*\(.*password/gi,
      severity: 'high',
      cwe: 'CWE-208',
      owasp: 'A07:2021',
      description: 'Password comparison vulnerable to timing attacks.',
      recommendation: 'Use constant-time comparison: crypto.timingSafeEqual()'
    },
    {
      pattern: /session\s*\[\s*["']user|req\.session\.user\s*=\s*req\.(body|query)/gi,
      severity: 'high',
      cwe: 'CWE-384',
      owasp: 'A07:2021',
      description: 'Session fixation: User data directly assigned to session.',
      recommendation: 'Regenerate session ID after authentication.'
    },
    {
      pattern: /sameSite\s*:\s*["']none["'](?!.*secure\s*:\s*true)/gi,
      severity: 'high',
      cwe: 'CWE-1275',
      owasp: 'A07:2021',
      description: 'SameSite=None without Secure flag.',
      recommendation: 'SameSite=None requires Secure flag for HTTPS.'
    }
  ],

  // ===========================================
  // A08:2021 - SOFTWARE AND DATA INTEGRITY FAILURES
  // ===========================================
  insecure_deserialization: [
    {
      pattern: /pickle\.loads?|cPickle\.loads?/gi,
      severity: 'critical',
      cwe: 'CWE-502',
      owasp: 'A08:2021',
      description: 'Python pickle deserialization - arbitrary code execution risk.',
      recommendation: 'Use JSON or implement secure deserialization with hmac verification.'
    },
    {
      pattern: /yaml\.load\s*\([^)]*(?!Loader\s*=\s*yaml\.SafeLoader)/gi,
      severity: 'critical',
      cwe: 'CWE-502',
      owasp: 'A08:2021',
      description: 'YAML load without SafeLoader - code execution risk.',
      recommendation: 'Use yaml.safe_load() or specify Loader=yaml.SafeLoader'
    },
    {
      pattern: /unserialize\s*\(|ObjectInputStream|readObject\s*\(/gi,
      severity: 'critical',
      cwe: 'CWE-502',
      owasp: 'A08:2021',
      description: 'Insecure deserialization detected.',
      recommendation: 'Avoid deserializing untrusted data. Use JSON with schema validation.'
    },
    {
      pattern: /Marshal\.load|JSON\.parse\s*\(.*\)\s*\.constructor/gi,
      severity: 'high',
      cwe: 'CWE-502',
      owasp: 'A08:2021',
      description: 'Potential prototype pollution or unsafe deserialization.',
      recommendation: 'Validate parsed data structure before use.'
    },
    {
      pattern: /eval\s*\(\s*JSON\.stringify|Function\s*\(\s*["']return\s*["']\s*\+/gi,
      severity: 'critical',
      cwe: 'CWE-502',
      owasp: 'A08:2021',
      description: 'Code execution via JSON manipulation.',
      recommendation: 'Never use eval() on serialized data.'
    }
  ],

  // ===========================================
  // A04:2021 - INSECURE DESIGN
  // ===========================================
  mass_assignment: [
    {
      pattern: /Object\.assign\s*\(\s*\w+\s*,\s*req\.body|\.create\s*\(\s*req\.body\s*\)|\.update\s*\(\s*req\.body\s*\)|\{\s*\.\.\.req\.body\s*\}/gi,
      severity: 'high',
      cwe: 'CWE-915',
      owasp: 'A04:2021',
      description: 'Mass assignment vulnerability - all request body fields accepted.',
      recommendation: 'Explicitly whitelist allowed fields.',
      example: {
        vulnerable: 'User.create(req.body)',
        secure: 'User.create({ name: req.body.name, email: req.body.email })'
      }
    },
    {
      pattern: /\.fillable\s*=\s*\[\]|protected\s+\$guarded\s*=\s*\[\]/gi,
      severity: 'high',
      cwe: 'CWE-915',
      owasp: 'A04:2021',
      description: 'Laravel mass assignment protection disabled.',
      recommendation: 'Define $fillable array with allowed fields.'
    }
  ],

  race_condition: [
    {
      pattern: /if\s*\(.*balance.*\)\s*\{[^}]*balance\s*[-+]=|check.*then.*update/gi,
      severity: 'medium',
      cwe: 'CWE-362',
      owasp: 'A04:2021',
      description: 'Potential race condition: check-then-act pattern.',
      recommendation: 'Use atomic operations or database transactions with proper locking.'
    }
  ],

  // ===========================================
  // A09:2021 - SECURITY LOGGING AND MONITORING FAILURES
  // ===========================================
  info_disclosure: [
    {
      pattern: /console\.log\s*\(.*(?:password|secret|token|key|credential|ssn|credit.?card)/gi,
      severity: 'high',
      cwe: 'CWE-532',
      owasp: 'A09:2021',
      description: 'Sensitive data logged to console.',
      recommendation: 'Remove sensitive data from logs or mask/redact values.'
    },
    {
      pattern: /logger\.\w+\s*\(.*(?:password|token|secret|api.?key)/gi,
      severity: 'high',
      cwe: 'CWE-532',
      owasp: 'A09:2021',
      description: 'Sensitive data in application logs.',
      recommendation: 'Implement log sanitization for sensitive fields.'
    },
    {
      pattern: /stackTrace|printStackTrace|console\.trace/gi,
      severity: 'medium',
      cwe: 'CWE-209',
      owasp: 'A09:2021',
      description: 'Stack trace exposure can reveal system information.',
      recommendation: 'Log stack traces server-side only, send generic errors to client.'
    },
    {
      pattern: /res\.send\s*\(\s*err|res\.json\s*\(\s*\{\s*error\s*:\s*err|catch.*res\.\w+\s*\(\s*e/gi,
      severity: 'medium',
      cwe: 'CWE-209',
      owasp: 'A09:2021',
      description: 'Error details sent to client.',
      recommendation: 'Send generic error messages, log details server-side.'
    }
  ],

  // ===========================================
  // A05:2021 - SECURITY MISCONFIGURATION
  // ===========================================
  insecure_config: [
    {
      pattern: /Access-Control-Allow-Origin\s*[=:]\s*["']\*["']|cors\s*\(\s*\)/gi,
      severity: 'medium',
      cwe: 'CWE-942',
      owasp: 'A05:2021',
      description: 'Overly permissive CORS configuration.',
      recommendation: 'Specify exact allowed origins instead of wildcard.'
    },
    {
      pattern: /secure\s*:\s*false|httpOnly\s*:\s*false|sameSite\s*:\s*false/gi,
      severity: 'high',
      cwe: 'CWE-614',
      owasp: 'A05:2021',
      description: 'Insecure cookie configuration.',
      recommendation: 'Set secure: true, httpOnly: true, sameSite: "strict" for session cookies.'
    },
    {
      pattern: /DEBUG\s*=\s*True|app\.debug\s*=\s*true|NODE_ENV.*development/gi,
      severity: 'medium',
      cwe: 'CWE-489',
      owasp: 'A05:2021',
      description: 'Debug mode may be enabled in production.',
      recommendation: 'Ensure debug mode is disabled in production environment.'
    },
    {
      pattern: /X-Frame-Options|frame-ancestors|Content-Security-Policy/gi,
      severity: 'info',
      cwe: 'CWE-1021',
      owasp: 'A05:2021',
      description: 'Security header configuration detected - verify proper values.',
      recommendation: 'Ensure X-Frame-Options: DENY and proper CSP is configured.'
    },
    {
      pattern: /ssl\s*:\s*\{\s*rejectUnauthorized\s*:\s*false|verify\s*=\s*False|VERIFY_PEER\s*=>\s*false/gi,
      severity: 'critical',
      cwe: 'CWE-295',
      owasp: 'A05:2021',
      description: 'SSL/TLS certificate verification disabled.',
      recommendation: 'Never disable certificate verification in production.'
    },
    {
      pattern: /AllowAllHostnameVerifier|ALLOW_ALL_HOSTNAME_VERIFIER|InsecureTrustManagerFactory/gi,
      severity: 'critical',
      cwe: 'CWE-295',
      owasp: 'A05:2021',
      description: 'Java hostname verification disabled.',
      recommendation: 'Use proper certificate and hostname verification.'
    }
  ],

  // ===========================================
  // A06:2021 - VULNERABLE AND OUTDATED COMPONENTS
  // ===========================================
  vulnerable_dependencies: [
    {
      pattern: /require\s*\(\s*["']jquery["']\)|jquery.*1\.[0-9]|jquery.*2\.[0-2]/gi,
      severity: 'medium',
      cwe: 'CWE-1104',
      owasp: 'A06:2021',
      description: 'Potentially outdated jQuery version.',
      recommendation: 'Update to latest jQuery version, check for known CVEs.'
    },
    {
      pattern: /lodash.*[34]\.[0-9]|"lodash"\s*:\s*"[^"]*[34]\./gi,
      severity: 'medium',
      cwe: 'CWE-1104',
      owasp: 'A06:2021',
      description: 'Potentially vulnerable lodash version.',
      recommendation: 'Update lodash to 4.17.21+ to fix prototype pollution.'
    }
  ],

  // ===========================================
  // A10:2021 - SERVER-SIDE REQUEST FORGERY (SSRF)
  // ===========================================
  ssrf: [
    {
      pattern: /axios\s*\.\s*get\s*\(\s*req\.|fetch\s*\(\s*req\.|request\s*\(\s*\{\s*url\s*:\s*req\./gi,
      severity: 'high',
      cwe: 'CWE-918',
      owasp: 'A10:2021',
      description: 'SSRF: HTTP request with user-controlled URL.',
      recommendation: 'Validate URLs against allowlist, block internal IP ranges.',
      example: {
        vulnerable: 'axios.get(req.body.url)',
        secure: 'const validatedUrl = validateUrl(req.body.url, allowedHosts);\naxios.get(validatedUrl)'
      }
    },
    {
      pattern: /urllib\.request\.urlopen\s*\(|requests\.\w+\s*\(\s*\w+/gi,
      severity: 'medium',
      cwe: 'CWE-918',
      owasp: 'A10:2021',
      description: 'Python HTTP request - verify URL source.',
      recommendation: 'Validate and sanitize URLs before requests.'
    },
    {
      pattern: /ImageIO\.read\s*\(\s*new\s+URL|URL\s*\(\s*\w+\s*\)\.openStream/gi,
      severity: 'high',
      cwe: 'CWE-918',
      owasp: 'A10:2021',
      description: 'Java URL fetch - potential SSRF.',
      recommendation: 'Validate URLs and block internal resources.'
    }
  ],

  // ===========================================
  // ADDITIONAL SECURITY PATTERNS
  // ===========================================
  xxe: [
    {
      pattern: /DocumentBuilderFactory|SAXParserFactory|XMLReader|TransformerFactory/gi,
      severity: 'high',
      cwe: 'CWE-611',
      owasp: 'A05:2021',
      description: 'XML parser detected - verify XXE protection.',
      recommendation: 'Disable DTDs and external entities in XML parser configuration.'
    },
    {
      pattern: /libxml_disable_entity_loader\s*\(\s*false|LIBXML_NOENT/gi,
      severity: 'critical',
      cwe: 'CWE-611',
      owasp: 'A05:2021',
      description: 'PHP XML external entity processing enabled.',
      recommendation: 'Set libxml_disable_entity_loader(true) before parsing.'
    },
    {
      pattern: /etree\.parse|lxml\.etree|xml\.etree/gi,
      severity: 'medium',
      cwe: 'CWE-611',
      owasp: 'A05:2021',
      description: 'Python XML parsing - verify XXE protection.',
      recommendation: 'Use defusedxml library for safe XML parsing.'
    }
  ],

  open_redirect: [
    {
      pattern: /res\.redirect\s*\(\s*req\.(query|params|body)|location\.href\s*=\s*(?:decodeURI|unescape)/gi,
      severity: 'medium',
      cwe: 'CWE-601',
      owasp: 'A01:2021',
      description: 'Open redirect: User-controlled redirect destination.',
      recommendation: 'Validate redirect URLs against allowlist of trusted domains.',
      example: {
        vulnerable: 'res.redirect(req.query.next)',
        secure: 'const safeUrl = validateRedirectUrl(req.query.next, allowedHosts);\nres.redirect(safeUrl)'
      }
    },
    {
      pattern: /header\s*\(\s*["']Location\s*:\s*["']\s*\.\s*\$/gi,
      severity: 'medium',
      cwe: 'CWE-601',
      owasp: 'A01:2021',
      description: 'PHP open redirect vulnerability.',
      recommendation: 'Validate redirect target against allowlist.'
    }
  ],

  prototype_pollution: [
    {
      pattern: /\[["']__proto__["']\]|\["constructor"\]\["prototype"\]|Object\.assign\s*\(\s*\{\}/gi,
      severity: 'high',
      cwe: 'CWE-1321',
      owasp: 'A08:2021',
      description: 'Prototype pollution vulnerability.',
      recommendation: 'Use Object.create(null) for maps, validate object keys.'
    },
    {
      pattern: /merge\s*\(.*req\.body|deepMerge|extend\s*\(\s*true/gi,
      severity: 'medium',
      cwe: 'CWE-1321',
      owasp: 'A08:2021',
      description: 'Deep merge operation with user input - prototype pollution risk.',
      recommendation: 'Sanitize keys, block __proto__ and constructor.prototype.'
    }
  ],

  template_injection: [
    {
      pattern: /\{\{.*\$|render.*\+.*req|template\.render\s*\(.*req/gi,
      severity: 'high',
      cwe: 'CWE-94',
      owasp: 'A03:2021',
      description: 'Server-Side Template Injection (SSTI) risk.',
      recommendation: 'Never pass user input directly to template engine.'
    },
    {
      pattern: /Jinja2|render_template_string|Template\s*\(\s*req/gi,
      severity: 'high',
      cwe: 'CWE-94',
      owasp: 'A03:2021',
      description: 'Python template injection risk.',
      recommendation: 'Use render_template() with separate template files.'
    }
  ],

  regex_dos: [
    {
      pattern: /\(\.\*\)\+|\(\.\+\)\*|\([^)]+\)\{[0-9]+,\}/gi,
      severity: 'medium',
      cwe: 'CWE-1333',
      owasp: 'A05:2021',
      description: 'ReDoS: Potentially vulnerable regex pattern.',
      recommendation: 'Review regex for catastrophic backtracking, use atomic groups.'
    },
    {
      pattern: /new\s+RegExp\s*\(\s*req\.|RegExp\s*\(\s*\$|\.match\s*\(\s*req\./gi,
      severity: 'high',
      cwe: 'CWE-1333',
      owasp: 'A05:2021',
      description: 'User-controlled regex - ReDoS risk.',
      recommendation: 'Never use user input in regex patterns, or sanitize thoroughly.'
    }
  ],

  file_upload: [
    {
      pattern: /multer|formidable|busboy|express-fileupload/gi,
      severity: 'info',
      cwe: 'CWE-434',
      owasp: 'A04:2021',
      description: 'File upload functionality detected.',
      recommendation: 'Validate file type (magic bytes, not just extension), limit size, store outside webroot.'
    },
    {
      pattern: /\.(exe|php|jsp|asp|sh|bat|cmd|ps1|dll)/gi,
      severity: 'high',
      cwe: 'CWE-434',
      owasp: 'A04:2021',
      description: 'Dangerous file extension in code.',
      recommendation: 'Block executable extensions in file upload validation.'
    }
  ]
};

/**
 * Language-specific security patterns
 * Based on OWASP Cheat Sheet Series for specific frameworks
 */
const LANGUAGE_PATTERNS = {
  javascript: [
    {
      pattern: /require\s*\(\s*[^"'`][^)]*\)|require\s*\(\s*\w+\s*\)/gi,
      type: 'dynamic_require',
      severity: 'high',
      cwe: 'CWE-94',
      description: 'Dynamic require() with variable - potential code injection.',
      recommendation: 'Use static require paths or validate against allowlist.'
    },
    {
      pattern: /\$\(.*\)\.on\s*\(\s*["']click["']/gi,
      type: 'dom_event',
      severity: 'info',
      cwe: 'CWE-79',
      description: 'jQuery event handler - ensure no XSS in dynamic handlers.',
      recommendation: 'Validate any dynamic content in event handlers.'
    },
    {
      pattern: /\.call\s*\(\s*this|\.apply\s*\(\s*this|Reflect\.apply/gi,
      type: 'function_manipulation',
      severity: 'medium',
      cwe: 'CWE-94',
      description: 'Dynamic function invocation detected.',
      recommendation: 'Validate function references before dynamic invocation.'
    },
    {
      pattern: /vm\.runInContext|vm\.runInNewContext|vm\.createContext/gi,
      type: 'sandbox_escape',
      severity: 'critical',
      cwe: 'CWE-94',
      description: 'Node.js VM module - potential sandbox escape.',
      recommendation: 'VM module is not a security mechanism. Use isolated processes.'
    },
    {
      pattern: /Buffer\.allocUnsafe|new\s+Buffer\s*\(/gi,
      type: 'buffer_issue',
      severity: 'medium',
      cwe: 'CWE-665',
      description: 'Uninitialized buffer may contain sensitive data.',
      recommendation: 'Use Buffer.alloc() for secure initialization.'
    }
  ],
  
  typescript: [
    {
      pattern: /as\s+any|<any>|:\s*any\b/gi,
      type: 'type_safety',
      severity: 'low',
      cwe: 'CWE-704',
      description: 'Use of "any" type bypasses TypeScript safety.',
      recommendation: 'Use proper types or unknown with type guards.'
    },
    {
      pattern: /@ts-ignore|@ts-nocheck/gi,
      type: 'type_safety',
      severity: 'medium',
      cwe: 'CWE-704',
      description: 'TypeScript type checking disabled.',
      recommendation: 'Fix type errors instead of suppressing them.'
    }
  ],

  php: [
    {
      pattern: /include\s*\(\s*\$|require\s*\(\s*\$|include_once\s*\(\s*\$|require_once\s*\(\s*\$/gi,
      type: 'lfi',
      severity: 'critical',
      cwe: 'CWE-98',
      description: 'Local File Inclusion (LFI) vulnerability.',
      recommendation: 'Never use user input in include/require. Use allowlist with basename().'
    },
    {
      pattern: /\$_(?:GET|POST|REQUEST|COOKIE)\s*\[[^\]]+\]/gi,
      type: 'superglobal_access',
      severity: 'medium',
      cwe: 'CWE-20',
      description: 'Direct superglobal access without validation.',
      recommendation: 'Use filter_input() or validated request objects.'
    },
    {
      pattern: /extract\s*\(\s*\$_(GET|POST|REQUEST)/gi,
      type: 'variable_injection',
      severity: 'critical',
      cwe: 'CWE-621',
      description: 'PHP extract() on user input - variable injection.',
      recommendation: 'Never use extract() on untrusted data.'
    },
    {
      pattern: /assert\s*\(\s*\$|create_function\s*\(/gi,
      type: 'code_injection',
      severity: 'critical',
      cwe: 'CWE-94',
      description: 'PHP code execution function.',
      recommendation: 'Avoid assert() with strings and create_function().'
    },
    {
      pattern: /preg_replace\s*\(\s*["']\/[^\/]*\/e["']/gi,
      type: 'preg_code_execution',
      severity: 'critical',
      cwe: 'CWE-94',
      description: 'preg_replace with /e modifier - code execution.',
      recommendation: 'Use preg_replace_callback() instead.'
    },
    {
      pattern: /mysql_query|mysql_connect|mysql_real_escape_string/gi,
      type: 'deprecated_mysql',
      severity: 'high',
      cwe: 'CWE-477',
      description: 'Deprecated mysql_* functions.',
      recommendation: 'Use PDO or MySQLi with prepared statements.'
    }
  ],

  java: [
    {
      pattern: /Runtime\.getRuntime\s*\(\s*\)\.exec/gi,
      type: 'command_injection',
      severity: 'critical',
      cwe: 'CWE-78',
      description: 'Java Runtime.exec() command execution.',
      recommendation: 'Use ProcessBuilder with argument list, validate all inputs.'
    },
    {
      pattern: /new\s+FileInputStream\s*\(\s*\w+|new\s+FileReader\s*\(\s*\w+/gi,
      type: 'path_traversal',
      severity: 'high',
      cwe: 'CWE-22',
      description: 'File access with potential path traversal.',
      recommendation: 'Canonicalize path and verify within allowed directory.'
    },
    {
      pattern: /Statement\s+\w+\s*=.*createStatement|executeQuery\s*\(\s*["'].*\+/gi,
      type: 'sql_injection',
      severity: 'critical',
      cwe: 'CWE-89',
      description: 'Java Statement instead of PreparedStatement.',
      recommendation: 'Use PreparedStatement with parameter binding.'
    },
    {
      pattern: /ObjectInputStream|readObject\s*\(/gi,
      type: 'deserialization',
      severity: 'critical',
      cwe: 'CWE-502',
      description: 'Java deserialization vulnerability.',
      recommendation: 'Implement ObjectInputFilter, avoid deserializing untrusted data.'
    },
    {
      pattern: /Cipher\.getInstance\s*\(\s*["']AES["']\s*\)|Cipher\.getInstance\s*\(\s*["']DES/gi,
      type: 'weak_crypto',
      severity: 'high',
      cwe: 'CWE-327',
      description: 'Cipher with default (ECB) mode.',
      recommendation: 'Use AES/GCM/NoPadding or AES/CBC/PKCS5Padding with random IV.'
    },
    {
      pattern: /TrustManager|X509TrustManager.*return|checkClientTrusted.*\{\s*\}/gi,
      type: 'ssl_bypass',
      severity: 'critical',
      cwe: 'CWE-295',
      description: 'Custom TrustManager may bypass SSL validation.',
      recommendation: 'Use default TrustManager, never ignore certificate errors.'
    },
    {
      pattern: /\.setEntity\s*\(\s*new\s+StringEntity\s*\(\s*\w+|HttpPost.*setHeader.*Content-Type/gi,
      type: 'http_request',
      severity: 'medium',
      cwe: 'CWE-918',
      description: 'HTTP client request - verify URL source.',
      recommendation: 'Validate URLs against allowlist for SSRF prevention.'
    }
  ],

  python: [
    {
      pattern: /__import__\s*\(\s*\w+|importlib\.import_module\s*\(\s*\w+/gi,
      type: 'dynamic_import',
      severity: 'high',
      cwe: 'CWE-94',
      description: 'Dynamic import with variable - code injection risk.',
      recommendation: 'Use static imports or validate against allowlist.'
    },
    {
      pattern: /getattr\s*\(\s*\w+\s*,\s*\w+|setattr\s*\(\s*\w+\s*,\s*\w+/gi,
      type: 'attribute_injection',
      severity: 'medium',
      cwe: 'CWE-915',
      description: 'Dynamic attribute access with variable.',
      recommendation: 'Validate attribute names against allowlist.'
    },
    {
      pattern: /compile\s*\(\s*\w+|exec\s*\(\s*\w+/gi,
      type: 'code_execution',
      severity: 'critical',
      cwe: 'CWE-94',
      description: 'Python code execution with variable.',
      recommendation: 'Avoid exec/compile with user input.'
    },
    {
      pattern: /input\s*\(\s*\)|raw_input\s*\(\s*\)/gi,
      type: 'input_validation',
      severity: 'low',
      cwe: 'CWE-20',
      description: 'User input without validation.',
      recommendation: 'Validate and sanitize all user input.'
    },
    {
      pattern: /flask\.request\.(args|form|data|json)\s*\.get|request\.(GET|POST)\s*\[/gi,
      type: 'request_data',
      severity: 'medium',
      cwe: 'CWE-20',
      description: 'Web framework request data access.',
      recommendation: 'Validate all request parameters before use.'
    },
    {
      pattern: /render_template_string\s*\(|Template\s*\(\s*\w+\s*\)\.render/gi,
      type: 'ssti',
      severity: 'critical',
      cwe: 'CWE-94',
      description: 'Server-Side Template Injection (SSTI).',
      recommendation: 'Use render_template() with file-based templates.'
    },
    {
      pattern: /shell\s*=\s*True|subprocess\.call\s*\(\s*["']|os\.popen/gi,
      type: 'command_injection',
      severity: 'critical',
      cwe: 'CWE-78',
      description: 'Python shell command execution.',
      recommendation: 'Use subprocess.run() with shell=False and argument list.'
    },
    {
      pattern: /hashlib\.md5\s*\(|hashlib\.sha1\s*\(/gi,
      type: 'weak_hash',
      severity: 'medium',
      cwe: 'CWE-328',
      description: 'Weak hash algorithm (MD5/SHA1).',
      recommendation: 'Use hashlib.sha256() or bcrypt for passwords.'
    }
  ],

  go: [
    {
      pattern: /exec\.Command\s*\(|exec\.CommandContext\s*\(/gi,
      type: 'command_execution',
      severity: 'high',
      cwe: 'CWE-78',
      description: 'Go command execution.',
      recommendation: 'Validate all command arguments, avoid shell expansion.'
    },
    {
      pattern: /fmt\.Sprintf\s*\(\s*\w+|fmt\.Fprintf\s*\(\s*\w+\s*,\s*\w+/gi,
      type: 'format_string',
      severity: 'medium',
      cwe: 'CWE-134',
      description: 'Go format string with variable.',
      recommendation: 'Use static format strings, validate user input.'
    },
    {
      pattern: /ioutil\.ReadAll|io\.ReadAll/gi,
      type: 'dos_risk',
      severity: 'medium',
      cwe: 'CWE-400',
      description: 'Unbounded read may cause DoS.',
      recommendation: 'Use io.LimitReader to bound reads.'
    },
    {
      pattern: /InsecureSkipVerify\s*:\s*true/gi,
      type: 'ssl_bypass',
      severity: 'critical',
      cwe: 'CWE-295',
      description: 'TLS certificate verification disabled.',
      recommendation: 'Never disable TLS verification in production.'
    },
    {
      pattern: /html\/template|text\/template.*Execute/gi,
      type: 'template',
      severity: 'medium',
      cwe: 'CWE-79',
      description: 'Go template execution.',
      recommendation: 'Use html/template (not text/template) for HTML output.'
    },
    {
      pattern: /sql\.Query\s*\(\s*["'].*\+|fmt\.Sprintf.*SELECT|fmt\.Sprintf.*INSERT/gi,
      type: 'sql_injection',
      severity: 'critical',
      cwe: 'CWE-89',
      description: 'Go SQL query with string formatting.',
      recommendation: 'Use parameterized queries: db.Query("SELECT * FROM users WHERE id = ?", id)'
    }
  ],

  ruby: [
    {
      pattern: /eval\s*\(\s*\w+|instance_eval|class_eval|module_eval/gi,
      type: 'code_execution',
      severity: 'critical',
      cwe: 'CWE-94',
      description: 'Ruby eval with potential user input.',
      recommendation: 'Avoid eval, use safe alternatives.'
    },
    {
      pattern: /send\s*\(\s*params|public_send\s*\(\s*params/gi,
      type: 'method_injection',
      severity: 'high',
      cwe: 'CWE-94',
      description: 'Ruby send with user-controlled method name.',
      recommendation: 'Validate method name against allowlist.'
    },
    {
      pattern: /\.where\s*\(\s*["'].*#\{|\.find_by_sql\s*\(\s*["'].*#\{/gi,
      type: 'sql_injection',
      severity: 'critical',
      cwe: 'CWE-89',
      description: 'Rails SQL injection via string interpolation.',
      recommendation: 'Use parameterized queries: User.where("name = ?", name)'
    },
    {
      pattern: /render\s+inline\s*:|render\s*\(\s*inline\s*:/gi,
      type: 'ssti',
      severity: 'high',
      cwe: 'CWE-94',
      description: 'Rails render inline - potential SSTI.',
      recommendation: 'Use render with file-based templates.'
    },
    {
      pattern: /\.html_safe|raw\s*\(/gi,
      type: 'xss',
      severity: 'high',
      cwe: 'CWE-79',
      description: 'Rails XSS bypass with html_safe/raw.',
      recommendation: 'Only use html_safe on trusted, sanitized content.'
    },
    {
      pattern: /attr_accessible\s*$|protect_from_forgery.*except/gi,
      type: 'security_bypass',
      severity: 'high',
      cwe: 'CWE-352',
      description: 'Rails security mechanism disabled.',
      recommendation: 'Use strong_parameters, dont disable CSRF protection.'
    },
    {
      pattern: /system\s*\(\s*["'].*#\{|`.*#\{|\%x\{.*#\{/gi,
      type: 'command_injection',
      severity: 'critical',
      cwe: 'CWE-78',
      description: 'Ruby command execution with interpolation.',
      recommendation: 'Use array form: system("command", arg1, arg2)'
    }
  ],

  csharp: [
    {
      pattern: /Process\.Start|ProcessStartInfo/gi,
      type: 'command_execution',
      severity: 'high',
      cwe: 'CWE-78',
      description: 'C# process execution.',
      recommendation: 'Validate all arguments, avoid UseShellExecute=true with user input.'
    },
    {
      pattern: /SqlCommand\s*\(\s*["'].*\+|\.CommandText\s*=.*\+/gi,
      type: 'sql_injection',
      severity: 'critical',
      cwe: 'CWE-89',
      description: 'C# SQL command with concatenation.',
      recommendation: 'Use SqlParameter for parameterized queries.'
    },
    {
      pattern: /BinaryFormatter|SoapFormatter|NetDataContractSerializer|ObjectStateFormatter/gi,
      type: 'deserialization',
      severity: 'critical',
      cwe: 'CWE-502',
      description: 'Insecure .NET deserialization.',
      recommendation: 'Use JSON serialization with known types.'
    },
    {
      pattern: /Assembly\.Load|Activator\.CreateInstance/gi,
      type: 'dynamic_loading',
      severity: 'high',
      cwe: 'CWE-94',
      description: 'Dynamic assembly/type loading.',
      recommendation: 'Validate assembly/type names against allowlist.'
    },
    {
      pattern: /\[ValidateInput\s*\(\s*false\s*\)\]|Request\.Unvalidated/gi,
      type: 'xss_bypass',
      severity: 'high',
      cwe: 'CWE-79',
      description: 'ASP.NET request validation disabled.',
      recommendation: 'Keep validation enabled, encode output properly.'
    }
  ],

  sql: [
    {
      pattern: /EXECUTE\s*\(\s*@|EXEC\s*\(\s*@|sp_executesql\s*.*\+/gi,
      type: 'dynamic_sql',
      severity: 'high',
      cwe: 'CWE-89',
      description: 'Dynamic SQL execution.',
      recommendation: 'Use parameterized sp_executesql with parameter binding.'
    },
    {
      pattern: /GRANT\s+ALL|WITH\s+GRANT\s+OPTION/gi,
      type: 'excessive_privileges',
      severity: 'high',
      cwe: 'CWE-250',
      description: 'Excessive database privileges.',
      recommendation: 'Grant minimum required privileges.'
    },
    {
      pattern: /--\s*password|--\s*secret|--\s*key/gi,
      type: 'comment_secrets',
      severity: 'medium',
      cwe: 'CWE-615',
      description: 'Sensitive data in SQL comments.',
      recommendation: 'Remove secrets from comments.'
    }
  ]
};

/**
 * Analyze code for vulnerabilities using OWASP-based patterns
 */
const analyzeCode = (code, language) => {
  const vulnerabilities = [];

  // Apply general security patterns
  for (const [category, patterns] of Object.entries(SECURITY_PATTERNS)) {
    for (const rule of patterns) {
      const regex = new RegExp(rule.pattern.source, rule.pattern.flags);
      let match;
      
      while ((match = regex.exec(code)) !== null) {
        const beforeMatch = code.substring(0, match.index);
        const lineNumber = (beforeMatch.match(/\n/g) || []).length + 1;
        
        // Get code context (line where vulnerability found)
        const lines = code.split('\n');
        const contextLine = lines[lineNumber - 1] || '';
        
        vulnerabilities.push({
          type: category.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
          severity: rule.severity,
          line: lineNumber,
          cwe: rule.cwe || null,
          owasp: rule.owasp || null,
          description: rule.description,
          recommendation: rule.recommendation,
          matchedCode: match[0].substring(0, 80),
          codeContext: contextLine.trim().substring(0, 100),
          example: rule.example || null
        });
      }
    }
  }

  // Apply language-specific patterns
  const langPatterns = LANGUAGE_PATTERNS[language] || [];
  for (const rule of langPatterns) {
    const regex = new RegExp(rule.pattern.source, rule.pattern.flags);
    let match;
    
    while ((match = regex.exec(code)) !== null) {
      const beforeMatch = code.substring(0, match.index);
      const lineNumber = (beforeMatch.match(/\n/g) || []).length + 1;
      
      const lines = code.split('\n');
      const contextLine = lines[lineNumber - 1] || '';
      
      vulnerabilities.push({
        type: rule.type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
        severity: rule.severity,
        line: lineNumber,
        cwe: rule.cwe || null,
        owasp: null,
        description: rule.description,
        recommendation: rule.recommendation,
        matchedCode: match[0].substring(0, 80),
        codeContext: contextLine.trim().substring(0, 100),
        example: rule.example || null
      });
    }
  }

  // Deduplicate by type and line
  const seen = new Set();
  return vulnerabilities.filter(v => {
    const key = v.type + '-' + v.line;
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  }).sort((a, b) => {
    const order = { critical: 0, high: 1, medium: 2, low: 3, info: 4 };
    return (order[a.severity] || 5) - (order[b.severity] || 5);
  });
};

/**
 * Calculate overall risk based on CVSS-like scoring
 */
const calculateOverallRisk = (vulns) => {
  if (vulns.length === 0) return 'secure';
  
  // Weight vulnerabilities
  const weights = { critical: 10, high: 7, medium: 4, low: 1, info: 0 };
  let totalScore = 0;
  let maxSeverity = 'info';
  
  for (const v of vulns) {
    totalScore += weights[v.severity] || 0;
    if ((weights[v.severity] || 0) > (weights[maxSeverity] || 0)) {
      maxSeverity = v.severity;
    }
  }
  
  // Determine overall risk
  if (vulns.some(v => v.severity === 'critical') || totalScore >= 20) return 'critical';
  if (vulns.some(v => v.severity === 'high') || totalScore >= 14) return 'high';
  if (vulns.some(v => v.severity === 'medium') || totalScore >= 8) return 'medium';
  return 'low';
};

/**
 * Generate comprehensive summary with OWASP Top 10 mapping
 */
const generateSummary = (vulns) => {
  if (vulns.length === 0) {
    return 'No security vulnerabilities detected. Code appears to follow secure coding practices.';
  }
  
  const counts = { critical: 0, high: 0, medium: 0, low: 0, info: 0 };
  const owaspCategories = new Set();
  const cweIds = new Set();
  
  vulns.forEach(v => {
    counts[v.severity]++;
    if (v.owasp) owaspCategories.add(v.owasp);
    if (v.cwe) cweIds.add(v.cwe);
  });
  
  const parts = [];
  if (counts.critical) parts.push(`${counts.critical} critical`);
  if (counts.high) parts.push(`${counts.high} high`);
  if (counts.medium) parts.push(`${counts.medium} medium`);
  if (counts.low) parts.push(`${counts.low} low`);
  if (counts.info) parts.push(`${counts.info} info`);
  
  let summary = `Found ${vulns.length} security issue(s): ${parts.join(', ')}.`;
  
  if (owaspCategories.size > 0) {
    summary += ` OWASP Top 10 categories affected: ${Array.from(owaspCategories).join(', ')}.`;
  }
  
  if (counts.critical > 0 || counts.high > 0) {
    summary += ' URGENT: Address critical and high severity issues before deployment.';
  }
  
  return summary;
};

/**
 * Generate OWASP compliance report
 */
const generateOwaspReport = (vulns) => {
  const owaspMapping = {
    'A01:2021': { name: 'Broken Access Control', issues: [] },
    'A02:2021': { name: 'Cryptographic Failures', issues: [] },
    'A03:2021': { name: 'Injection', issues: [] },
    'A04:2021': { name: 'Insecure Design', issues: [] },
    'A05:2021': { name: 'Security Misconfiguration', issues: [] },
    'A06:2021': { name: 'Vulnerable Components', issues: [] },
    'A07:2021': { name: 'Auth Failures', issues: [] },
    'A08:2021': { name: 'Data Integrity Failures', issues: [] },
    'A09:2021': { name: 'Logging Failures', issues: [] },
    'A10:2021': { name: 'SSRF', issues: [] }
  };
  
  for (const v of vulns) {
    if (v.owasp && owaspMapping[v.owasp]) {
      owaspMapping[v.owasp].issues.push({
        type: v.type,
        severity: v.severity,
        line: v.line,
        cwe: v.cwe
      });
    }
  }
  
  return Object.entries(owaspMapping)
    .filter(([_, data]) => data.issues.length > 0)
    .map(([code, data]) => ({
      code,
      name: data.name,
      issueCount: data.issues.length,
      issues: data.issues
    }));
};

const reviewCode = async (userId, codeSnippet, language, title) => {
  const canReview = await subscriptionService.canPerformCodeReview(userId);
  if (!canReview.allowed) throw new Error(canReview.reason);

  const review = new CodeReview({
    user: userId,
    language,
    codeSnippet,
    title: title || 'Untitled Review',
    status: 'processing'
  });
  await review.save();

  const startTime = Date.now();
  try {
    const vulnerabilities = analyzeCode(codeSnippet, language);
    const owaspReport = generateOwaspReport(vulnerabilities);
    
    review.status = 'completed';
    review.vulnerabilities = vulnerabilities;
    review.overallRisk = calculateOverallRisk(vulnerabilities);
    review.summary = generateSummary(vulnerabilities);
    review.owaspCompliance = owaspReport;
    review.processingTime = Date.now() - startTime;
    review.analysisMetadata = {
      patternsChecked: Object.keys(SECURITY_PATTERNS).length,
      languagePatternsChecked: (LANGUAGE_PATTERNS[language] || []).length,
      linesAnalyzed: codeSnippet.split('\n').length,
      analysisVersion: '2.0-owasp'
    };
    
    await review.save();
    await subscriptionService.incrementCodeReviewCount(userId);
    return review;
  } catch (error) {
    review.status = 'failed';
    review.error = error.message;
    await review.save();
    throw error;
  }
};

const getReviewHistory = async (userId, page = 1, limit = 10) => {
  const skip = (page - 1) * limit;
  const [reviews, total] = await Promise.all([
    CodeReview.find({ user: userId }).sort({ createdAt: -1 }).skip(skip).limit(limit).select('-codeSnippet'),
    CodeReview.countDocuments({ user: userId })
  ]);
  return { reviews, pagination: { page, limit, total, pages: Math.ceil(total / limit) } };
};

const getReviewById = async (userId, reviewId) => {
  const review = await CodeReview.findOne({ _id: reviewId, user: userId });
  if (!review) throw new Error('Review not found');
  return review;
};

const deleteReview = async (userId, reviewId) => {
  const result = await CodeReview.deleteOne({ _id: reviewId, user: userId });
  if (result.deletedCount === 0) throw new Error('Review not found');
  return { success: true };
};

const getReviewStats = async (userId) => {
  const stats = await CodeReview.aggregate([
    { $match: { user: userId } },
    {
      $group: {
        _id: null,
        totalReviews: { $sum: 1 },
        completedReviews: { $sum: { $cond: [{ $eq: ['$status', 'completed'] }, 1, 0] } },
        criticalVulns: {
          $sum: { $size: { $filter: { input: { $ifNull: ['$vulnerabilities', []] }, cond: { $eq: ['$$this.severity', 'critical'] } } } }
        },
        highVulns: {
          $sum: { $size: { $filter: { input: { $ifNull: ['$vulnerabilities', []] }, cond: { $eq: ['$$this.severity', 'high'] } } } }
        },
        avgProcessingTime: { $avg: '$processingTime' }
      }
    }
  ]);
  return stats[0] || { totalReviews: 0, completedReviews: 0, criticalVulns: 0, highVulns: 0, avgProcessingTime: 0 };
};

module.exports = { 
  reviewCode, 
  getReviewHistory, 
  getReviewById, 
  deleteReview, 
  getReviewStats, 
  analyzeCode,
  generateOwaspReport,
  SECURITY_PATTERNS,
  LANGUAGE_PATTERNS
};




################################################################################
## FILE 60: pdfGenerator.js
## Path: server/src/services/pdfGenerator.js
################################################################################

const PDFDocument = require('pdfkit');

/**
 * Generate PDF report from scan data
 */
const generateScanPDF = (scan, res) => {
  const doc = new PDFDocument({ margin: 50 });

  // Set response headers
  res.setHeader('Content-Type', 'application/pdf');
  res.setHeader('Content-Disposition', `attachment; filename=scan-${scan._id}.pdf`);

  // Pipe PDF to response
  doc.pipe(res);

  // Add header
  doc.fontSize(24)
     .font('Helvetica-Bold')
     .text('ReconWeb Security Scan Report', { align: 'center' });

  doc.moveDown();

  // Add scan metadata
  doc.fontSize(12)
     .font('Helvetica');

  addSection(doc, 'Scan Information');
  addKeyValue(doc, 'Scan ID', scan._id.toString());
  addKeyValue(doc, 'Target URL', scan.targetUrl);
  addKeyValue(doc, 'Created At', new Date(scan.createdAt).toLocaleString());
  addKeyValue(doc, 'Status', scan.status || 'completed');

  if (scan.notes) {
    addKeyValue(doc, 'Notes', scan.notes);
  }

  doc.moveDown();

  // Add summary section if available
  if (scan.summary) {
    addSection(doc, 'Executive Summary');
    
    const { riskLevel, riskScore, counts } = scan.summary;
    
    // Risk level with color
    doc.font('Helvetica-Bold').text('Risk Level: ', { continued: true });
    setRiskColor(doc, riskLevel);
    doc.text(riskLevel.toUpperCase());
    doc.font('Helvetica');

    doc.moveDown(0.5);
    addKeyValue(doc, 'Risk Score', `${riskScore}/100`);
    
    if (counts) {
      doc.moveDown(0.5);
      doc.font('Helvetica-Bold').text('Findings Summary:');
      doc.font('Helvetica');
      
      if (counts.critical > 0) {
        addKeyValue(doc, '  Critical', counts.critical.toString(), 'red');
      }
      if (counts.high > 0) {
        addKeyValue(doc, '  High', counts.high.toString(), 'orange');
      }
      if (counts.medium > 0) {
        addKeyValue(doc, '  Medium', counts.medium.toString(), 'blue');
      }
      if (counts.low > 0) {
        addKeyValue(doc, '  Low', counts.low.toString(), 'gray');
      }
      if (counts.info > 0) {
        addKeyValue(doc, '  Info', counts.info.toString(), 'gray');
      }
      
      addKeyValue(doc, '  Total Findings', counts.total.toString(), 'black');
    }

    doc.moveDown();
  }

  // Add detailed results for each tool
  addSection(doc, 'Detailed Tool Results');

  scan.results.forEach((result, index) => {
    if (index > 0) {
      doc.addPage();
    }

    // Tool header
    doc.fontSize(16)
       .font('Helvetica-Bold')
       .text(`Tool: ${result.tool.toUpperCase()}`);

    doc.fontSize(12)
       .font('Helvetica');

    doc.moveDown(0.5);

    // Tool status
    doc.font('Helvetica-Bold').text('Status: ', { continued: true });
    doc.fillColor(result.status === 'completed' ? 'green' : 'red')
       .text(result.status.toUpperCase());
    doc.fillColor('black');

    doc.moveDown(0.5);

    // Timestamps
    if (result.startedAt) {
      addKeyValue(doc, 'Started', new Date(result.startedAt).toLocaleString());
    }
    if (result.finishedAt) {
      addKeyValue(doc, 'Finished', new Date(result.finishedAt).toLocaleString());
    }

    doc.moveDown();

    // Findings section
    if (result.findings && result.findings.length > 0) {
      doc.font('Helvetica-Bold')
         .fontSize(14)
         .text(`Findings (${result.findings.length}):`);
      doc.fontSize(12);

      doc.moveDown(0.5);

      result.findings.forEach((finding, fIdx) => {
        // Add page break if needed
        if (doc.y > 650) {
          doc.addPage();
        }

        doc.font('Helvetica-Bold')
           .text(`${fIdx + 1}. `, { continued: true });

        // Severity badge
        const severityColor = getSeverityColor(finding.severity);
        doc.fillColor(severityColor)
           .text(`[${finding.severity.toUpperCase()}] `, { continued: true });
        doc.fillColor('black');

        // Description
        doc.font('Helvetica')
           .text(finding.description, { width: 500 });

        if (finding.path) {
          doc.fontSize(10)
             .fillColor('gray')
             .text(`   Path: ${finding.path}`);
          doc.fontSize(12).fillColor('black');
        }

        if (finding.templateId) {
          doc.fontSize(10)
             .fillColor('gray')
             .text(`   Template: ${finding.templateId}`);
          doc.fontSize(12).fillColor('black');
        }

        doc.moveDown(0.5);
      });
    } else {
      doc.fillColor('gray')
         .text('No specific findings detected.');
      doc.fillColor('black');
    }

    doc.moveDown();

    // Options
    if (result.options && Object.keys(result.options).length > 0) {
      doc.font('Helvetica-Bold')
         .fontSize(12)
         .text('Scan Options:');
      doc.font('Helvetica')
         .fontSize(10)
         .fillColor('gray')
         .text(JSON.stringify(result.options, null, 2), { width: 500 });
      doc.fontSize(12).fillColor('black');

      doc.moveDown();
    }

    // Raw output (truncated)
    if (result.output) {
      doc.font('Helvetica-Bold')
         .fontSize(12)
         .text('Raw Output (first 1000 characters):');
      doc.font('Courier')
         .fontSize(8)
         .fillColor('gray')
         .text(result.output.substring(0, 1000), { width: 500 });
      
      if (result.output.length > 1000) {
        doc.text('... (truncated)');
      }

      doc.font('Helvetica')
         .fontSize(12)
         .fillColor('black');

      doc.moveDown();
    }

    // Errors
    if (result.error) {
      doc.font('Helvetica-Bold')
         .fillColor('red')
         .text('Errors:');
      doc.font('Helvetica')
         .fontSize(10)
         .text(result.error, { width: 500 });
      doc.fontSize(12).fillColor('black');
    }
  });

  // Footer on last page
  doc.addPage();
  doc.fontSize(10)
     .fillColor('gray')
     .text('Report generated by ReconWeb Security Platform', { align: 'center' });
  doc.text(`Generated on: ${new Date().toLocaleString()}`, { align: 'center' });
  doc.text('https://reconweb.security', { align: 'center' });

  // Finalize PDF
  doc.end();
};

// Helper functions
const addSection = (doc, title) => {
  doc.fontSize(16)
     .font('Helvetica-Bold')
     .fillColor('darkblue')
     .text(title);
  doc.fillColor('black')
     .fontSize(12)
     .font('Helvetica');
  doc.moveDown(0.5);
};

const addKeyValue = (doc, key, value, color = 'black') => {
  doc.font('Helvetica-Bold').text(`${key}: `, { continued: true });
  doc.font('Helvetica').fillColor(color).text(value);
  doc.fillColor('black');
};

const setRiskColor = (doc, riskLevel) => {
  const colors = {
    critical: 'red',
    high: 'orange',
    medium: 'blue',
    low: 'green',
    safe: 'green',
    info: 'gray'
  };
  doc.fillColor(colors[riskLevel] || 'black');
};

const getSeverityColor = (severity) => {
  const colors = {
    critical: 'red',
    high: 'orange',
    medium: 'blue',
    low: 'darkgreen',
    info: 'gray'
  };
  return colors[severity] || 'black';
};

module.exports = {
  generateScanPDF
};




################################################################################
## FILE 61: remediationService.js
## Path: server/src/services/remediationService.js
################################################################################

const subscriptionService = require('./subscriptionService');

/**
 * Remediation database for common vulnerabilities
 */
const REMEDIATION_DB = {
  sql_injection: {
    title: 'SQL Injection',
    description: 'SQL Injection allows attackers to manipulate database queries.',
    steps: [
      'Use parameterized queries or prepared statements',
      'Use ORM (Object-Relational Mapping) libraries',
      'Implement input validation and sanitization',
      'Apply principle of least privilege to database accounts',
      'Use stored procedures with parameterized inputs'
    ],
    codeExample: `// Bad - Vulnerable to SQL injection
const query = "SELECT * FROM users WHERE id = " + userId;

// Good - Parameterized query
const query = "SELECT * FROM users WHERE id = ?";
db.query(query, [userId]);

// Good - Using ORM (e.g., Sequelize)
User.findOne({ where: { id: userId } });`,
    resources: [
      'https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html',
      'https://owasp.org/www-community/attacks/SQL_Injection'
    ]
  },

  xss: {
    title: 'Cross-Site Scripting (XSS)',
    description: 'XSS allows attackers to inject malicious scripts into web pages.',
    steps: [
      'Encode output data (HTML, JavaScript, URL encoding)',
      'Use Content Security Policy (CSP) headers',
      'Sanitize HTML input with libraries like DOMPurify',
      'Avoid innerHTML, use textContent instead',
      'Validate and sanitize all user inputs'
    ],
    codeExample: `// Bad - XSS vulnerable
element.innerHTML = userInput;

// Good - Safe text content
element.textContent = userInput;

// Good - Sanitized HTML (using DOMPurify)
element.innerHTML = DOMPurify.sanitize(userInput);

// Good - React automatically escapes
<div>{userInput}</div>`,
    resources: [
      'https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html',
      'https://owasp.org/www-community/attacks/xss/'
    ]
  },

  command_injection: {
    title: 'Command Injection',
    description: 'Command injection allows execution of arbitrary system commands.',
    steps: [
      'Avoid using shell commands with user input',
      'Use language-native alternatives instead of shell commands',
      'If shell is necessary, use allowlists for permitted commands',
      'Never concatenate user input into commands',
      'Use subprocess with shell=False (Python) or execFile (Node.js)'
    ],
    codeExample: `// Bad - Command injection vulnerable
exec('ping ' + userInput);

// Good - Use execFile with arguments array
execFile('ping', ['-c', '4', validatedHost]);

// Python - Bad
os.system('ping ' + user_input)

// Python - Good
subprocess.run(['ping', '-c', '4', validated_host], shell=False)`,
    resources: [
      'https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html'
    ]
  },

  path_traversal: {
    title: 'Path Traversal',
    description: 'Path traversal allows access to files outside the intended directory.',
    steps: [
      'Validate and sanitize file paths',
      'Use path.resolve() and verify result is within allowed directory',
      'Implement allowlist for permitted file names',
      'Never use user input directly in file operations',
      'Use chroot or containerization for additional isolation'
    ],
    codeExample: `// Bad - Path traversal vulnerable
const file = './uploads/' + filename;

// Good - Validate path
const path = require('path');
const safePath = path.join('./uploads', path.basename(filename));
const resolved = path.resolve(safePath);
if (!resolved.startsWith(path.resolve('./uploads'))) {
  throw new Error('Invalid path');
}`,
    resources: [
      'https://owasp.org/www-community/attacks/Path_Traversal'
    ]
  },

  hardcoded_secrets: {
    title: 'Hardcoded Secrets',
    description: 'Hardcoded credentials can be extracted from source code.',
    steps: [
      'Use environment variables for all secrets',
      'Use a secrets management service (AWS Secrets Manager, HashiCorp Vault)',
      'Never commit secrets to version control',
      'Add secret patterns to .gitignore',
      'Use git-secrets or similar tools to prevent accidental commits'
    ],
    codeExample: `// Bad - Hardcoded secret
const apiKey = 'sk-abc123secret';

// Good - Environment variable
const apiKey = process.env.API_KEY;

// Good - With validation
const apiKey = process.env.API_KEY;
if (!apiKey) throw new Error('API_KEY not configured');`,
    resources: [
      'https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html'
    ]
  },

  insecure_crypto: {
    title: 'Insecure Cryptography',
    description: 'Weak cryptographic algorithms can be broken by attackers.',
    steps: [
      'Use bcrypt, scrypt, or Argon2 for password hashing',
      'Use AES-256-GCM for encryption',
      'Use SHA-256 or SHA-3 for hashing (not MD5/SHA-1)',
      'Use crypto.randomBytes() for secure random numbers',
      'Keep cryptographic libraries updated'
    ],
    codeExample: `// Bad - MD5 is broken
const hash = crypto.createHash('md5').update(password).digest('hex');

// Good - bcrypt for passwords
const bcrypt = require('bcrypt');
const hash = await bcrypt.hash(password, 12);

// Good - SHA-256 for general hashing
const hash = crypto.createHash('sha256').update(data).digest('hex');

// Good - Secure random
const token = crypto.randomBytes(32).toString('hex');`,
    resources: [
      'https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html'
    ]
  },

  auth_issues: {
    title: 'Authentication Issues',
    description: 'Weak authentication can lead to unauthorized access.',
    steps: [
      'Always verify JWT signatures with jwt.verify()',
      'Use strong algorithms (RS256, HS256)',
      'Implement proper session management',
      'Use constant-time comparison for tokens',
      'Implement rate limiting and account lockout'
    ],
    codeExample: `// Bad - Decode without verification
const payload = jwt.decode(token);

// Good - Verify signature
const payload = jwt.verify(token, secretKey, { algorithms: ['HS256'] });

// Good - Constant-time comparison
const crypto = require('crypto');
const isValid = crypto.timingSafeEqual(
  Buffer.from(providedToken),
  Buffer.from(storedToken)
);`,
    resources: [
      'https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html'
    ]
  },

  insecure_deserialization: {
    title: 'Insecure Deserialization',
    description: 'Deserializing untrusted data can lead to code execution.',
    steps: [
      'Avoid deserializing untrusted data',
      'Use safe deserialization methods (yaml.safe_load)',
      'Implement integrity checks (signatures, checksums)',
      'Restrict deserialization to expected types',
      'Keep serialization libraries updated'
    ],
    codeExample: `# Python - Bad
data = pickle.loads(user_input)  # RCE vulnerability!

# Python - Good
data = json.loads(user_input)  # Safe for JSON

# YAML - Bad
data = yaml.load(user_input)  # Arbitrary code execution

# YAML - Good  
data = yaml.safe_load(user_input)`,
    resources: [
      'https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html'
    ]
  },

  insecure_config: {
    title: 'Insecure Configuration',
    description: 'Misconfiguration can expose the application to attacks.',
    steps: [
      'Set secure cookie flags (Secure, HttpOnly, SameSite)',
      'Configure CORS with specific origins (not *)',
      'Enable security headers (CSP, HSTS, X-Frame-Options)',
      'Disable debug mode in production',
      'Use HTTPS everywhere'
    ],
    codeExample: `// Secure cookie configuration
res.cookie('session', token, {
  secure: true,      // HTTPS only
  httpOnly: true,    // No JavaScript access
  sameSite: 'strict', // CSRF protection
  maxAge: 3600000    // 1 hour
});

// Secure CORS
app.use(cors({
  origin: ['https://myapp.com'],
  credentials: true
}));`,
    resources: [
      'https://cheatsheetseries.owasp.org/cheatsheets/Secure_Headers_Cheat_Sheet.html'
    ]
  }
};

/**
 * Get quick tips by severity
 */
const getQuickTips = (severity) => {
  const tips = {
    critical: [
      'Stop and fix immediately - this is exploitable',
      'Check logs for signs of exploitation',
      'Consider taking affected service offline',
      'Notify security team'
    ],
    high: [
      'Schedule fix within 24-48 hours',
      'Apply security patches',
      'Review access controls',
      'Enable additional monitoring'
    ],
    medium: [
      'Plan fix within 1-2 weeks',
      'Review security configuration',
      'Update security headers',
      'Add to security backlog'
    ],
    low: [
      'Add to improvement backlog',
      'Review in next security audit',
      'Document for compliance'
    ]
  };
  return tips[severity] || tips.medium;
};

/**
 * Map finding type to remediation key
 */
const mapTypeToKey = (type) => {
  const mapping = {
    'sql injection': 'sql_injection',
    'xss': 'xss',
    'cross site scripting': 'xss',
    'command injection': 'command_injection',
    'command execution': 'command_injection',
    'path traversal': 'path_traversal',
    'hardcoded secrets': 'hardcoded_secrets',
    'insecure crypto': 'insecure_crypto',
    'auth issues': 'auth_issues',
    'authentication': 'auth_issues',
    'insecure deserialization': 'insecure_deserialization',
    'insecure config': 'insecure_config',
    'info disclosure': 'insecure_config',
    'lfi': 'path_traversal',
    'dynamic require': 'command_injection',
    'dynamic import': 'command_injection'
  };
  return mapping[type.toLowerCase()] || null;
};

/**
 * Get basic remediation for findings
 */
const getBasicRemediationForFindings = (findings) => {
  if (!findings || findings.length === 0) {
    return { message: 'No findings to remediate', remediations: [] };
  }

  const remediations = findings.map(finding => {
    const key = mapTypeToKey(finding.type || finding.title || '');
    const remediation = key ? REMEDIATION_DB[key] : null;
    const tips = getQuickTips(finding.severity);

    return {
      finding: finding.title || finding.type || finding.description,
      severity: finding.severity,
      guidance: remediation || {
        title: 'General Security Issue',
        description: 'Review and address this security finding.',
        steps: [
          'Research the specific vulnerability',
          'Check vendor documentation',
          'Implement defense in depth',
          'Test the fix thoroughly'
        ]
      },
      quickTips: tips
    };
  });

  return { message: 'Remediation guidance', remediations };
};

/**
 * Generate detailed remediation (VIP feature)
 */
const generateRemediation = async (userId, scanId, findings, targetUrl) => {
  const hasFeature = await subscriptionService.hasAutoRemediation(userId);
  if (!hasFeature) {
    throw new Error('Detailed remediation is only available for VIP subscribers.');
  }

  if (!findings || findings.length === 0) {
    return {
      summary: 'No findings to remediate.',
      prioritizedActions: [],
      quickWins: ['Continue regular scanning', 'Keep software updated'],
      longTermRecommendations: ['Implement security training', 'Regular penetration testing']
    };
  }

  // Group findings by type
  const grouped = {};
  findings.forEach(f => {
    const key = mapTypeToKey(f.type || f.title || '') || 'other';
    if (!grouped[key]) grouped[key] = [];
    grouped[key].push(f);
  });

  // Generate prioritized actions
  const prioritizedActions = [];
  let priority = 1;

  for (const [key, items] of Object.entries(grouped)) {
    const remediation = REMEDIATION_DB[key];
    if (!remediation) continue;

    const highestSeverity = items.reduce((max, item) => {
      const order = { critical: 4, high: 3, medium: 2, low: 1 };
      return order[item.severity] > order[max] ? item.severity : max;
    }, 'low');

    prioritizedActions.push({
      priority: priority++,
      title: remediation.title,
      finding: items.map(i => i.description || i.title).join('; '),
      severity: highestSeverity,
      effort: highestSeverity === 'critical' ? 'high' : 'medium',
      description: remediation.description,
      steps: remediation.steps,
      codeExample: remediation.codeExample,
      resources: remediation.resources
    });
  }

  // Sort by severity
  prioritizedActions.sort((a, b) => {
    const order = { critical: 0, high: 1, medium: 2, low: 3 };
    return order[a.severity] - order[b.severity];
  });

  const criticalCount = findings.filter(f => f.severity === 'critical').length;
  const highCount = findings.filter(f => f.severity === 'high').length;

  return {
    scanId,
    targetUrl,
    generatedAt: new Date().toISOString(),
    summary: `Found ${findings.length} security issues (${criticalCount} critical, ${highCount} high). Immediate action required for critical issues.`,
    prioritizedActions,
    quickWins: [
      'Update all dependencies to latest secure versions',
      'Enable security headers (CSP, HSTS)',
      'Review and rotate any exposed credentials',
      'Enable WAF rules for common attacks'
    ],
    longTermRecommendations: [
      'Implement automated security scanning in CI/CD',
      'Conduct regular penetration testing',
      'Provide security training for developers',
      'Establish incident response procedures'
    ],
    complianceNotes: {
      owasp: 'Review OWASP Top 10 for comprehensive coverage',
      pciDss: criticalCount > 0 ? 'Critical vulnerabilities may affect PCI-DSS compliance' : 'Address high-severity issues for compliance'
    }
  };
};

module.exports = {
  generateRemediation,
  getBasicRemediationForFindings,
  getQuickTips,
  REMEDIATION_DB
};




################################################################################
## FILE 62: resultParser.js
## Path: server/src/services/resultParser.js
################################################################################

/**
 * Result Parser Service
 * Ph√¢n t√≠ch output t·ª´ c√°c security tools v√† tr√≠ch xu·∫•t c√°c l·ªó h·ªïng/ph√°t hi·ªán
 */

/**
 * Remove ANSI color codes from text
 */
const stripAnsiCodes = (text) => {
  if (!text) return '';
  // Match all ANSI escape sequences
  return text.replace(/\x1b\[[0-9;]*m|\[\[?[0-9;]*m|\[0m/g, '');
};

/**
 * Parse Nikto output ƒë·ªÉ t√¨m c√°c l·ªó h·ªïng
 */
const parseNiktoOutput = (output) => {
  if (!output) return [];
  
  const cleanOutput = stripAnsiCodes(output);
  const findings = [];
  const lines = cleanOutput.split('\n');
  
  for (const line of lines) {
    // Nikto findings th∆∞·ªùng b·∫Øt ƒë·∫ßu v·ªõi + ho·∫∑c -
    if (line.trim().startsWith('+') && !line.includes('Target') && !line.includes('Server:') && !line.includes('Start Time:')) {
      const text = line.substring(1).trim();
      
      // Ph√¢n lo·∫°i m·ª©c ƒë·ªô nghi√™m tr·ªçng d·ª±a tr√™n keywords
      let severity = 'info';
      const lowerText = text.toLowerCase();
      
      if (lowerText.includes('vulnerability') || lowerText.includes('exploit') || 
          lowerText.includes('sql injection') || lowerText.includes('xss') ||
          lowerText.includes('command injection') || lowerText.includes('rce')) {
        severity = 'critical';
      } else if (lowerText.includes('outdated') || lowerText.includes('insecure') ||
                 lowerText.includes('weak') || lowerText.includes('exposed')) {
        severity = 'high';
      } else if (lowerText.includes('missing') || lowerText.includes('unnecessary') ||
                 lowerText.includes('information disclosure')) {
        severity = 'medium';
      } else if (lowerText.includes('allowed') || lowerText.includes('retrieved')) {
        severity = 'low';
      }
      
      findings.push({
        type: 'vulnerability',
        severity,
        description: text,
        tool: 'nikto'
      });
    }
  }
  
  return findings;
};

/**
 * Parse Gobuster output ƒë·ªÉ t√¨m c√°c th∆∞ m·ª•c/file
 */
const parseGobusterOutput = (output) => {
  if (!output) return [];
  
  const findings = [];
  const lines = output.split('\n');
  
  for (const line of lines) {
    // Gobuster output: /path (Status: 200) [Size: 1234]
    const match = line.match(/^(\/[^\s]+)\s+\(Status:\s*(\d+)\)/);
    if (match) {
      const [, path, status] = match;
      
      let severity = 'info';
      const lowerPath = path.toLowerCase();
      
      // Ph√°t hi·ªán c√°c ƒë∆∞·ªùng d·∫´n nh·∫°y c·∫£m
      if (lowerPath.includes('admin') || lowerPath.includes('backup') ||
          lowerPath.includes('config') || lowerPath.includes('.git') ||
          lowerPath.includes('phpinfo') || lowerPath.includes('upload')) {
        severity = status === '200' ? 'high' : 'medium';
      } else if (lowerPath.includes('login') || lowerPath.includes('dashboard') ||
                 lowerPath.includes('panel') || lowerPath.includes('test')) {
        severity = status === '200' ? 'medium' : 'low';
      } else if (status === '200' || status === '301' || status === '302') {
        severity = 'low';
      }
      
      findings.push({
        type: 'directory',
        severity,
        description: `Found path: ${path} (Status: ${status})`,
        path,
        statusCode: parseInt(status),
        tool: 'gobuster'
      });
    }
  }
  
  return findings;
};

/**
 * Parse Nuclei output ƒë·ªÉ t√¨m c√°c template match
 */
const parseNucleiOutput = (output) => {
  if (!output) return [];
  
  const findings = [];
  const lines = output.split('\n');
  
  // Remove ANSI color codes
  const cleanLine = (line) => line.replace(/\x1b\[[0-9;]*m|\[\[?[0-9;]*m/g, '');
  
  for (const line of lines) {
    const cleaned = cleanLine(line);
    
    // Nuclei format variations:
    // 1. [severity] [template-id] [matcher-name] url
    // 2. [template-id:matcher] [severity] [protocol] url
    // 3. [template-id] [severity] url
    
    // Pattern 1: [template-id:extra] [protocol] url - common format
    let match = cleaned.match(/\[([^\]]+)\]\s+\[([^\]]+)\]\s+(.+)/);
    if (match) {
      const [, part1, part2, url] = match;
      
      // Determine severity from the parts
      let severity = 'info';
      let templateId = part1;
      
      const severityKeywords = {
        'critical': ['critical', 'rce', 'sqli', 'ssti'],
        'high': ['high', 'xss', 'lfi', 'rfi', 'ssrf', 'xxe'],
        'medium': ['medium', 'redirect', 'exposure'],
        'low': ['low', 'info-disclosure'],
        'info': ['info', 'tech-detect', 'waf-detect', 'http-missing']
      };
      
      const lowerPart1 = part1.toLowerCase();
      const lowerPart2 = part2.toLowerCase();
      
      for (const [sev, keywords] of Object.entries(severityKeywords)) {
        if (keywords.some(kw => lowerPart1.includes(kw) || lowerPart2.includes(kw))) {
          severity = sev;
          break;
        }
      }
      
      // Extract template name
      if (part1.includes(':')) {
        templateId = part1.split(':')[0];
      }
      
      findings.push({
        type: 'vulnerability',
        severity,
        description: `${templateId}: ${part2}`,
        templateId,
        url: url.trim(),
        tool: 'nuclei'
      });
      continue;
    }
    
    // Pattern 2: Simple match with severity in brackets
    match = cleaned.match(/\[(critical|high|medium|low|info)\]\s+\[([^\]]+)\]\s+(.+)/i);
    if (match) {
      const [, severity, templateId, url] = match;
      
      findings.push({
        type: 'vulnerability',
        severity: severity.toLowerCase(),
        description: `Template matched: ${templateId}`,
        templateId,
        url: url.trim(),
        tool: 'nuclei'
      });
    }
  }
  
  return findings;
};

/**
 * Parse SQLMap output ƒë·ªÉ t√¨m SQL injection
 */
const parseSQLMapOutput = (output) => {
  if (!output) return [];
  
  const findings = [];
  const lowerOutput = output.toLowerCase();
  
  // T√¨m c√°c d·∫•u hi·ªáu SQL injection
  if (lowerOutput.includes('parameter') && lowerOutput.includes('vulnerable')) {
    const lines = output.split('\n');
    for (const line of lines) {
      if (line.toLowerCase().includes('parameter') && line.toLowerCase().includes('vulnerable')) {
        findings.push({
          type: 'vulnerability',
          severity: 'critical',
          description: line.trim(),
          tool: 'sqlmap'
        });
      }
    }
  }
  
  // T√¨m backend DBMS ƒë∆∞·ª£c ph√°t hi·ªán
  if (lowerOutput.includes('back-end dbms:')) {
    const dbmsMatch = output.match(/back-end DBMS:\s*([^\n]+)/i);
    if (dbmsMatch) {
      findings.push({
        type: 'information',
        severity: 'info',
        description: `Database detected: ${dbmsMatch[1].trim()}`,
        tool: 'sqlmap'
      });
    }
  }
  
  // N·∫øu kh√¥ng t√¨m th·∫•y l·ªó h·ªïng
  if (findings.length === 0 && lowerOutput.includes('all tested parameters do not appear to be injectable')) {
    findings.push({
      type: 'information',
      severity: 'info',
      description: 'No SQL injection vulnerabilities found',
      tool: 'sqlmap'
    });
  }
  
  return findings;
};

/**
 * Parse XSStrike output ƒë·ªÉ t√¨m XSS
 */
const parseXSStrikeOutput = (output) => {
  if (!output) return [];
  
  const cleanOutput = stripAnsiCodes(output);
  const findings = [];
  const lines = cleanOutput.split('\n');
  
  for (const line of lines) {
    const trimmed = line.trim();
    const lowerLine = trimmed.toLowerCase();
    
    // XSStrike findings patterns
    // Reflections found
    if (lowerLine.includes('reflections found:')) {
      const match = trimmed.match(/reflections found:\s*(\d+)/i);
      if (match && parseInt(match[1]) > 0) {
        findings.push({
          type: 'information',
          severity: 'medium',
          description: `Reflections found: ${match[1]} - potential XSS vectors detected`,
          tool: 'xsstrike'
        });
      }
    }
    
    // Payloads generated
    if (lowerLine.includes('payloads generated:')) {
      const match = trimmed.match(/payloads generated:\s*(\d+)/i);
      if (match && parseInt(match[1]) > 0) {
        findings.push({
          type: 'information',
          severity: 'medium',
          description: `XSS Payloads generated: ${match[1]}`,
          tool: 'xsstrike'
        });
      }
    }
    
    // WAF detection
    if (lowerLine.includes('waf status:')) {
      const wafStatus = trimmed.replace(/.*waf status:\s*/i, '').trim();
      findings.push({
        type: 'information',
        severity: wafStatus.toLowerCase() === 'offline' ? 'medium' : 'info',
        description: `WAF Status: ${wafStatus}`,
        tool: 'xsstrike'
      });
    }
    
    // Testing parameter
    if (lowerLine.includes('testing parameter:')) {
      const param = trimmed.replace(/.*testing parameter:\s*/i, '').trim();
      findings.push({
        type: 'information',
        severity: 'info',
        description: `Testing parameter: ${param}`,
        tool: 'xsstrike'
      });
    }
    
    // Confirmed XSS
    if (lowerLine.includes('confirmed') || lowerLine.includes('vulnerable')) {
      findings.push({
        type: 'vulnerability',
        severity: 'critical',
        description: trimmed,
        tool: 'xsstrike'
      });
    }
    
    // Payload found/working
    if ((lowerLine.includes('payload') && lowerLine.includes('work')) ||
        lowerLine.includes('[vuln]')) {
      findings.push({
        type: 'vulnerability',
        severity: 'high',
        description: trimmed,
        tool: 'xsstrike'
      });
    }
  }
  
  // If no findings but had some output, add summary
  if (findings.length === 0 && cleanOutput.length > 100) {
    if (cleanOutput.toLowerCase().includes('no xss') || 
        cleanOutput.toLowerCase().includes('not vulnerable')) {
      findings.push({
        type: 'information',
        severity: 'info',
        description: 'No XSS vulnerabilities found',
        tool: 'xsstrike'
      });
    }
  }
  
  return findings;
};

/**
 * Parse WPScan output ƒë·ªÉ t√¨m l·ªó h·ªïng WordPress
 */
const parseWPScanOutput = (output) => {
  if (!output) return [];
  
  const findings = [];
  const lines = output.split('\n');
  
  for (const line of lines) {
    const trimmed = line.trim();
    
    // T√¨m vulnerabilities
    if (trimmed.startsWith('[!]')) {
      const text = trimmed.substring(3).trim();
      
      let severity = 'medium';
      const lowerText = text.toLowerCase();
      
      if (lowerText.includes('version') && lowerText.includes('vulnerabilit')) {
        severity = 'high';
      } else if (lowerText.includes('outdated') || lowerText.includes('insecure')) {
        severity = 'medium';
      }
      
      findings.push({
        type: 'vulnerability',
        severity,
        description: text,
        tool: 'wpscan'
      });
    }
    
    // T√¨m interesting findings
    if (trimmed.startsWith('[+]')) {
      const text = trimmed.substring(3).trim();
      
      if (text.toLowerCase().includes('wordpress version') || 
          text.toLowerCase().includes('plugin') ||
          text.toLowerCase().includes('theme')) {
        findings.push({
          type: 'information',
          severity: 'info',
          description: text,
          tool: 'wpscan'
        });
      }
    }
  }
  
  return findings;
};

/**
 * Parse output d·ª±a tr√™n tool
 */
const parseToolOutput = (tool, output) => {
  switch (tool) {
    case 'nikto':
      return parseNiktoOutput(output);
    case 'gobuster':
      return parseGobusterOutput(output);
    case 'nuclei':
      return parseNucleiOutput(output);
    case 'sqlmap':
      return parseSQLMapOutput(output);
    case 'xsstrike':
      return parseXSStrikeOutput(output);
    case 'wpscan':
      return parseWPScanOutput(output);
    default:
      return [];
  }
};

/**
 * T·∫°o summary t·ªïng quan t·ª´ t·∫•t c·∫£ findings
 */
const generateSummary = (allFindings) => {
  const counts = {
    critical: 0,
    high: 0,
    medium: 0,
    low: 0,
    info: 0,
    total: 0
  };
  
  const vulnerabilities = [];
  const directories = [];
  const information = [];
  
  for (const finding of allFindings) {
    counts.total++;
    counts[finding.severity] = (counts[finding.severity] || 0) + 1;
    
    if (finding.type === 'vulnerability') {
      vulnerabilities.push(finding);
    } else if (finding.type === 'directory') {
      directories.push(finding);
    } else if (finding.type === 'information') {
      information.push(finding);
    }
  }
  
  // X√°c ƒë·ªãnh risk level t·ªïng th·ªÉ
  let riskLevel = 'safe';
  let riskScore = 0;
  
  if (counts.critical > 0) {
    riskLevel = 'critical';
    riskScore = 100;
  } else if (counts.high > 0) {
    riskLevel = 'high';
    riskScore = 75;
  } else if (counts.medium > 0) {
    riskLevel = 'medium';
    riskScore = 50;
  } else if (counts.low > 0) {
    riskLevel = 'low';
    riskScore = 25;
  } else if (counts.info > 0) {
    riskLevel = 'info';
    riskScore = 10;
  }
  
  return {
    riskLevel,
    riskScore,
    counts,
    vulnerabilities: vulnerabilities.length,
    directories: directories.length,
    information: information.length,
    hasVulnerabilities: counts.critical > 0 || counts.high > 0 || counts.medium > 0
  };
};

module.exports = {
  parseToolOutput,
  generateSummary,
  parseNiktoOutput,
  parseGobusterOutput,
  parseNucleiOutput,
  parseSQLMapOutput,
  parseXSStrikeOutput,
  parseWPScanOutput
};




################################################################################
## FILE 63: scanService.js
## Path: server/src/services/scanService.js
################################################################################

const { spawn, execSync } = require('child_process');
const path = require('path');
const os = require('os');
const resultParser = require('./resultParser');

const SUPPORTED_TOOLS = ['nikto', 'gobuster', 'nuclei', 'sqlmap', 'xsstrike', 'wpscan'];

// Extended PATH ƒë·ªÉ t√¨m tools trong c√°c th∆∞ m·ª•c ph·ªï bi·∫øn
const EXTENDED_PATH = [
  process.env.PATH,
  path.join(os.homedir(), 'go', 'bin'),  // Go binaries (nuclei)
  '/usr/local/bin',
  '/usr/bin',
].filter(Boolean).join(':');

const sanitizeString = (value, { maxLength = 300, allowEmpty = false, name } = {}) => {
  if (value === undefined || value === null) {
    throw new Error(`Option '${name}' requires a value`);
  }

  const str = String(value);

  if (!allowEmpty && str.trim().length === 0) {
    throw new Error(`Option '${name}' cannot be empty`);
  }

  if (str.length > maxLength) {
    throw new Error(`Option '${name}' exceeds ${maxLength} characters`);
  }

  if (/[\0\r\n]/.test(str)) {
    throw new Error(`Option '${name}' contains invalid control characters`);
  }

  return str;
};

const sanitizeNumber = (value, { min, max, integer = false, name } = {}) => {
  const num = Number(value);

  if (Number.isNaN(num)) {
    throw new Error(`Option '${name}' must be a valid number`);
  }

  if (integer && !Number.isInteger(num)) {
    throw new Error(`Option '${name}' must be an integer`);
  }

  if (min !== undefined && num < min) {
    throw new Error(`Option '${name}' must be at least ${min}`);
  }

  if (max !== undefined && num > max) {
    throw new Error(`Option '${name}' must be at most ${max}`);
  }

  return num;
};

const sanitizeBoolean = (value) => {
  if (typeof value === 'boolean') {
    return value;
  }

  if (typeof value === 'string') {
    return ['true', '1', 'yes'].includes(value.toLowerCase());
  }

  return Boolean(value);
};

const sanitizeList = (value, definition) => {
  const list = Array.isArray(value)
    ? value
    : String(value)
        .split(',')
        .map((entry) => entry.trim())
        .filter((entry) => entry.length > 0);

  if (definition.maxItems && list.length > definition.maxItems) {
    throw new Error(`Option '${definition.name}' accepts at most ${definition.maxItems} values`);
  }

  return list.map((entry) =>
    sanitizeString(entry, {
      name: definition.name,
      maxLength: definition.maxLength || 200,
      allowEmpty: false,
    })
  );
};

const extractExtraArgs = (options, toolName) => {
  if (!options || options.extraArgs === undefined) {
    return [];
  }

  const raw = options.extraArgs;
  delete options.extraArgs;

  if (!Array.isArray(raw)) {
    throw new Error(`extraArgs for tool '${toolName}' must be an array of strings`);
  }

  if (raw.length > 10) {
    throw new Error(`extraArgs for tool '${toolName}' supports up to 10 entries`);
  }

  return raw.map((arg, index) =>
    sanitizeString(arg, {
      name: `extraArgs[${index}]`,
      maxLength: 200,
      allowEmpty: false,
    })
  );
};

const processOptions = (toolName, schema, options = {}) => {
  const args = [];
  const sanitizedOptions = {};

  Object.entries(options).forEach(([key, value]) => {
    if (value === undefined || value === null || value === '') {
      return;
    }

    const definition = schema[key];
    if (!definition) {
      throw new Error(`Unsupported option '${key}' for tool '${toolName}'`);
    }

    const { flag, type, ...rest } = definition;

    switch (type) {
      case 'boolean': {
        const boolValue = sanitizeBoolean(value);
        sanitizedOptions[key] = boolValue;
        if (boolValue) {
          args.push(flag);
        }
        break;
      }
      case 'number': {
        const numberValue = sanitizeNumber(value, { ...rest, name: key });
        sanitizedOptions[key] = numberValue;
        args.push(flag, String(numberValue));
        break;
      }
      case 'string': {
        const stringValue = sanitizeString(value, { ...rest, name: key, allowEmpty: rest.allowEmpty });
        sanitizedOptions[key] = stringValue;
        args.push(flag, stringValue);
        break;
      }
      case 'csv': {
        const list = sanitizeList(value, { ...rest, name: key });
        if (list.length > 0) {
          sanitizedOptions[key] = list.join(',');
          args.push(flag, list.join(','));
        }
        break;
      }
      case 'array': {
        const list = sanitizeList(value, { ...rest, name: key });
        if (list.length > 0) {
          sanitizedOptions[key] = list;
          list.forEach((entry) => {
            args.push(flag, entry);
          });
        }
        break;
      }
      default:
        throw new Error(`Unsupported option type '${type}' for '${key}'`);
    }
  });

  return { args, sanitizedOptions };
};

const sanitizeGobusterMode = (mode) => {
  const allowed = ['dir', 'dns', 'vhost', 'fuzz'];
  const normalized = sanitizeString(mode || 'dir', { name: 'mode', maxLength: 10 });

  if (!allowed.includes(normalized)) {
    throw new Error(`Unsupported Gobuster mode '${normalized}'. Allowed: ${allowed.join(', ')}`);
  }

  return normalized;
};

const sanitizePath = (value, name) =>
  sanitizeString(value, {
    name,
    maxLength: 400,
    allowEmpty: false,
  });

const niktoOptionSchema = {
  timeout: { flag: '-timeout', type: 'number', min: 1, max: 3600, integer: true },
  maxTime: { flag: '-maxtime', type: 'number', min: 1, max: 86400, integer: true },
  tuning: { flag: '-Tuning', type: 'string', maxLength: 40 },
  userAgent: { flag: '-useragent', type: 'string', maxLength: 200 },
  port: { flag: '-port', type: 'number', min: 1, max: 65535, integer: true },
  ssl: { flag: '-ssl', type: 'boolean' },
  hostHeader: { flag: '-vhost', type: 'string', maxLength: 200 },
  cookies: { flag: '-C', type: 'string', maxLength: 400 },
  plugins: { flag: '-Plugins', type: 'string', maxLength: 200 },
};

const gobusterOptionSchema = {
  extensions: { flag: '-x', type: 'csv', maxItems: 10, maxLength: 40 },
  statusCodes: { flag: '-s', type: 'csv', maxItems: 20, maxLength: 20 },
  threads: { flag: '-t', type: 'number', min: 1, max: 200, integer: true },
  delay: { flag: '--delay', type: 'number', min: 0, max: 10 },
  timeout: { flag: '-to', type: 'number', min: 1, max: 300, integer: true },
  userAgent: { flag: '-a', type: 'string', maxLength: 200 },
  proxy: { flag: '-p', type: 'string', maxLength: 200 },
  followRedirect: { flag: '-r', type: 'boolean' },
  includeLength: { flag: '-l', type: 'boolean' },
  noTlsValidation: { flag: '-k', type: 'boolean' },
};

const nucleiOptionSchema = {
  templates: { flag: '-t', type: 'array', maxItems: 10, maxLength: 200 },
  severity: { flag: '-severity', type: 'string', maxLength: 80 },
  tags: { flag: '-tags', type: 'csv', maxItems: 20, maxLength: 80 },
  excludeTags: { flag: '-etags', type: 'csv', maxItems: 20, maxLength: 80 },
  rateLimit: { flag: '-rate-limit', type: 'number', min: 1, max: 10000, integer: true },
  bulkSize: { flag: '-bulk-size', type: 'number', min: 1, max: 1000, integer: true },
  concurrency: { flag: '-c', type: 'number', min: 1, max: 500, integer: true },
  headless: { flag: '-headless', type: 'boolean' },
  proxy: { flag: '-proxy', type: 'string', maxLength: 200 },
  resolvers: { flag: '-r', type: 'string', maxLength: 200 },
};

const sqlmapOptionSchema = {
  batch: { flag: '--batch', type: 'boolean' },
  risk: { flag: '--risk', type: 'number', min: 0, max: 3, integer: true },
  level: { flag: '--level', type: 'number', min: 1, max: 5, integer: true },
  threads: { flag: '--threads', type: 'number', min: 1, max: 10, integer: true },
  tamper: { flag: '--tamper', type: 'string', maxLength: 200 },
  dbms: { flag: '--dbms', type: 'string', maxLength: 120 },
  os: { flag: '--os', type: 'string', maxLength: 120 },
  tech: { flag: '--tech', type: 'string', maxLength: 200 },
  timeout: { flag: '--timeout', type: 'number', min: 1, max: 600, integer: true },
  delay: { flag: '--delay', type: 'number', min: 0, max: 10 },
  tor: { flag: '--tor', type: 'boolean' },
  randomAgent: { flag: '--random-agent', type: 'boolean' },
};

const xsstrikeOptionSchema = {
  crawl: { flag: '--crawl', type: 'boolean' },
  blind: { flag: '--blind', type: 'boolean' },
  skip: { flag: '--skip', type: 'boolean' },
  fuzz: { flag: '--fuzzer', type: 'boolean' },
  delay: { flag: '--delay', type: 'number', min: 0, max: 10 },
  headers: { flag: '--headers', type: 'string', maxLength: 400 },
  threads: { flag: '--threads', type: 'number', min: 1, max: 20, integer: true },
};

const wpscanOptionSchema = {
  apiToken: { flag: '--api-token', type: 'string', maxLength: 100 },
  enumeratePlugins: { flag: '--enumerate', type: 'string', maxLength: 20 },
  enumerateThemes: { flag: '--enumerate', type: 'string', maxLength: 20 },
  enumerateUsers: { flag: '--enumerate', type: 'string', maxLength: 20 },
  randomUserAgent: { flag: '--random-user-agent', type: 'boolean' },
  disableTlsChecks: { flag: '--disable-tls-checks', type: 'boolean' },
  ignoreMainRedirect: { flag: '--ignore-main-redirect', type: 'boolean' },
  userAgent: { flag: '--user-agent', type: 'string', maxLength: 200 },
  proxy: { flag: '--proxy', type: 'string', maxLength: 200 },
  cookieString: { flag: '--cookie-string', type: 'string', maxLength: 500 },
  maxThreads: { flag: '--max-threads', type: 'number', min: 1, max: 50, integer: true },
  throttle: { flag: '--throttle', type: 'number', min: 0, max: 5000, integer: true },
  requestTimeout: { flag: '--request-timeout', type: 'number', min: 1, max: 600, integer: true },
  connectTimeout: { flag: '--connect-timeout', type: 'number', min: 1, max: 300, integer: true },
  stealthy: { flag: '--stealthy', type: 'boolean' },
};

const TOOL_DEFINITIONS = {
  nikto: {
    command: 'nikto',
    buildArgs: (targetUrl, rawOptions = {}) => {
      const options = { ...rawOptions };
      const extraArgs = extractExtraArgs(options, 'nikto');
      const { args: optionArgs, sanitizedOptions } = processOptions('nikto', niktoOptionSchema, options);
      const normalizedOptions = { ...sanitizedOptions };
      if (extraArgs.length) {
        normalizedOptions.extraArgs = extraArgs;
      }
      return {
        args: ['-h', targetUrl, ...optionArgs, ...extraArgs],
        normalizedOptions,
      };
    },
  },
  gobuster: {
    command: 'gobuster',
    buildArgs: (targetUrl, rawOptions = {}) => {
      const options = { ...rawOptions };
      const mode = sanitizeGobusterMode(options.mode);
      if (!options.wordlist) {
        throw new Error('Gobuster requires the "wordlist" option.');
      }
      const wordlist = sanitizePath(options.wordlist, 'wordlist');
      delete options.mode;
      delete options.wordlist;
      const extraArgs = extractExtraArgs(options, 'gobuster');
      const { args: optionArgs, sanitizedOptions } = processOptions('gobuster', gobusterOptionSchema, options);
      const normalizedOptions = { mode, wordlist, ...sanitizedOptions };
      if (extraArgs.length) {
        normalizedOptions.extraArgs = extraArgs;
      }
      return {
        args: [mode, '-u', targetUrl, '-w', wordlist, ...optionArgs, ...extraArgs],
        normalizedOptions,
      };
    },
  },
  nuclei: {
    command: 'nuclei',
    buildArgs: (targetUrl, rawOptions = {}) => {
      const options = { ...rawOptions };
      const extraArgs = extractExtraArgs(options, 'nuclei');
      const { args: optionArgs, sanitizedOptions } = processOptions('nuclei', nucleiOptionSchema, options);
      const normalizedOptions = { ...sanitizedOptions };
      if (extraArgs.length) {
        normalizedOptions.extraArgs = extraArgs;
      }
      return {
        args: ['-u', targetUrl, ...optionArgs, ...extraArgs],
        normalizedOptions,
      };
    },
  },
  sqlmap: {
    command: 'sqlmap',
    buildArgs: (targetUrl, rawOptions = {}) => {
      const options = { ...rawOptions };
      const extraArgs = extractExtraArgs(options, 'sqlmap');
      const { args: optionArgs, sanitizedOptions } = processOptions('sqlmap', sqlmapOptionSchema, options);
      const normalizedOptions = { ...sanitizedOptions };
      if (extraArgs.length) {
        normalizedOptions.extraArgs = extraArgs;
      }
      return {
        args: ['-u', targetUrl, ...optionArgs, ...extraArgs],
        normalizedOptions,
      };
    },
  },
  xsstrike: {
    command: 'xsstrike',
    buildArgs: (targetUrl, rawOptions = {}) => {
      const options = { ...rawOptions };
      const extraArgs = extractExtraArgs(options, 'xsstrike');
      const { args: optionArgs, sanitizedOptions } = processOptions('xsstrike', xsstrikeOptionSchema, options);
      const normalizedOptions = { ...sanitizedOptions };
      if (extraArgs.length) {
        normalizedOptions.extraArgs = extraArgs;
      }
      return {
        args: ['-u', targetUrl, ...optionArgs, ...extraArgs],
        normalizedOptions,
      };
    },
  },
  wpscan: {
    command: 'wpscan',
    buildArgs: (targetUrl, rawOptions = {}) => {
      const options = { ...rawOptions };
      const extraArgs = extractExtraArgs(options, 'wpscan');
      const { args: optionArgs, sanitizedOptions } = processOptions('wpscan', wpscanOptionSchema, options);
      const normalizedOptions = { ...sanitizedOptions };
      if (extraArgs.length) {
        normalizedOptions.extraArgs = extraArgs;
      }
      return {
        // --no-update: skip database update check (tr√°nh timeout)
        // --no-banner: gi·∫£m output
        // --format cli-no-color: output d·ªÖ parse
        args: ['--url', targetUrl, '--no-update', '--no-banner', '--format', 'cli-no-color', ...optionArgs, ...extraArgs],
        normalizedOptions,
      };
    },
  },
};

// Default timeout: 5 minutes (300 seconds)
// Tool-specific timeouts (in milliseconds)
const TOOL_TIMEOUTS = {
  nikto: 10 * 60 * 1000,    // 10 minutes
  gobuster: 10 * 60 * 1000, // 10 minutes
  nuclei: 15 * 60 * 1000,   // 15 minutes
  sqlmap: 10 * 60 * 1000,   // 10 minutes
  xsstrike: 10 * 60 * 1000, // 10 minutes (XSStrike c·∫ßn th·ªùi gian ƒë·ªÉ test payloads)
  wpscan: 5 * 60 * 1000,    // 5 minutes
};

const DEFAULT_TIMEOUT = 5 * 60 * 1000; // 5 minutes

const runCommand = (command, args = [], timeout = DEFAULT_TIMEOUT) =>
  new Promise((resolve) => {
    console.log(`[ScanService] Starting ${command} with args:`, args.join(' '));
    console.log(`[ScanService] Timeout set to ${timeout / 1000} seconds`);
    
    // S·ª≠ d·ª•ng EXTENDED_PATH ƒë·ªÉ t√¨m command
    const child = spawn(command, args, { 
      shell: false,
      env: { ...process.env, PATH: EXTENDED_PATH }
    });
    let killed = false;

    let stdout = '';
    let stderr = '';

    // Set timeout ƒë·ªÉ t·ª± ƒë·ªông kill process n·∫øu ch·∫°y qu√° l√¢u
    const timeoutId = setTimeout(() => {
      killed = true;
      child.kill('SIGTERM');
      
      // N·∫øu SIGTERM kh√¥ng work, d√πng SIGKILL sau 5 gi√¢y
      setTimeout(() => {
        if (!child.killed) {
          child.kill('SIGKILL');
        }
      }, 5000);
    }, timeout);

    child.stdout.on('data', (data) => {
      stdout += data.toString();
    });

    child.stderr.on('data', (data) => {
      stderr += data.toString();
    });

    child.on('error', (error) => {
      clearTimeout(timeoutId);
      console.log(`[ScanService] ${command} error:`, error.message);
      resolve({ status: 'failed', output: stdout, error: error.message });
    });

    child.on('close', (code) => {
      clearTimeout(timeoutId);
      
      if (killed) {
        console.log(`[ScanService] ${command} TIMEOUT after ${timeout / 1000}s`);
        resolve({
          status: 'timeout',
          output: stdout,
          error: `Process timed out after ${timeout / 1000} seconds. Partial output included.`,
        });
      } else if (code === 0) {
        console.log(`[ScanService] ${command} completed successfully`);
        // N·∫øu exit code = 0, kh√¥ng coi stderr l√† error (nhi·ªÅu tool in info ra stderr)
        resolve({ status: 'completed', output: stdout, error: null });
      } else {
        console.log(`[ScanService] ${command} failed with code ${code}`);
        resolve({
          status: 'failed',
          output: stdout,
          error: stderr || `Process exited with code ${code}`,
        });
      }
    });
  });

const runTool = async (toolName, targetUrl, rawOptions = {}) => {
  if (!SUPPORTED_TOOLS.includes(toolName)) {
    throw new Error(`Unsupported tool '${toolName}'`);
  }

  const definition = TOOL_DEFINITIONS[toolName];
  const timeout = TOOL_TIMEOUTS[toolName] || DEFAULT_TIMEOUT;

  const { args, normalizedOptions } = definition.buildArgs(targetUrl, rawOptions);
  const executionResult = await runCommand(definition.command, args, timeout);

  return {
    ...executionResult,
    options: normalizedOptions,
    args,
  };
};

const runScanBatch = async (targetUrl, toolRequests = []) => {
  const results = [];
  const allFindings = [];

  for (const request of toolRequests) {
    const toolName = typeof request.tool === 'string' ? request.tool.toLowerCase() : '';
    const options = request.options || {};

    const startTime = new Date();

    try {
      const execution = await runTool(toolName, targetUrl, options);
      
      // Parse output ƒë·ªÉ tr√≠ch xu·∫•t findings
      const findings = resultParser.parseToolOutput(toolName, execution.output);
      allFindings.push(...findings);
      
      results.push({
        tool: toolName,
        status: execution.status,
        options: execution.options,
        output: execution.output,
        error: execution.error,
        findings,
        startedAt: startTime,
        finishedAt: new Date(),
      });
    } catch (error) {
      results.push({
        tool: toolName,
        status: 'failed',
        options,
        output: '',
        error: error.message,
        findings: [],
        startedAt: startTime,
        finishedAt: new Date(),
      });
    }
  }

  // T·∫°o summary t·ªïng quan
  const summary = resultParser.generateSummary(allFindings);

  return { results, summary };
};

/**
 * Ch·∫°y scan batch trong background v·ªõi update progress
 */
const runScanBatchAsync = async (scanId, targetUrl, toolRequests = []) => {
  const Scan = require('../models/Scan');
  
  try {
    // Update status sang running
    await Scan.findByIdAndUpdate(scanId, { 
      status: 'running',
      progress: 0
    });

    const allFindings = [];
    const totalTools = toolRequests.length;

    for (let i = 0; i < toolRequests.length; i++) {
      const request = toolRequests[i];
      const toolName = typeof request.tool === 'string' ? request.tool.toLowerCase() : '';
      const options = request.options || {};

      const startTime = new Date();

      // Update tool status to running
      await Scan.findOneAndUpdate(
        { _id: scanId, 'results.tool': toolName },
        { 
          $set: { 
            'results.$.status': 'running',
            'results.$.startedAt': startTime
          }
        }
      );

      try {
        const execution = await runTool(toolName, targetUrl, options);
        
        // Parse output ƒë·ªÉ tr√≠ch xu·∫•t findings
        const findings = resultParser.parseToolOutput(toolName, execution.output);
        allFindings.push(...findings);
        
        // Update tool result
        await Scan.findOneAndUpdate(
          { _id: scanId, 'results.tool': toolName },
          { 
            $set: { 
              'results.$.status': execution.status,
              'results.$.output': execution.output,
              'results.$.error': execution.error,
              'results.$.findings': findings,
              'results.$.finishedAt': new Date()
            }
          }
        );
      } catch (error) {
        // Update tool with error
        await Scan.findOneAndUpdate(
          { _id: scanId, 'results.tool': toolName },
          { 
            $set: { 
              'results.$.status': 'failed',
              'results.$.error': error.message,
              'results.$.finishedAt': new Date()
            }
          }
        );
      }

      // Update overall progress
      const progress = Math.round(((i + 1) / totalTools) * 100);
      await Scan.findByIdAndUpdate(scanId, { progress });
    }

    // T·∫°o summary v√† update scan status
    const summary = resultParser.generateSummary(allFindings);
    await Scan.findByIdAndUpdate(scanId, { 
      status: 'completed',
      progress: 100,
      summary
    });

  } catch (error) {
    console.error('Scan batch error:', error);
    await Scan.findByIdAndUpdate(scanId, { 
      status: 'failed',
      progress: 100
    });
  }
};

const getSupportedTools = () => [...SUPPORTED_TOOLS];

/**
 * Ki·ªÉm tra tool c√≥ ƒë∆∞·ª£c c√†i ƒë·∫∑t tr√™n h·ªá th·ªëng kh√¥ng
 */
const isToolInstalled = (toolName) => {
  try {
    // S·ª≠ d·ª•ng EXTENDED_PATH ƒë·ªÉ t√¨m tool
    execSync(`which ${toolName}`, { 
      stdio: 'ignore',
      env: { ...process.env, PATH: EXTENDED_PATH }
    });
    return true;
  } catch {
    return false;
  }
};

/**
 * L·∫•y danh s√°ch c√°c tool ƒë√£ ƒë∆∞·ª£c c√†i ƒë·∫∑t
 */
const getInstalledTools = () => {
  const installed = [];
  for (const tool of SUPPORTED_TOOLS) {
    if (isToolInstalled(tool)) {
      installed.push(tool);
    }
  }
  console.log('[ScanService] Installed tools:', installed);
  return installed;
};

module.exports = {
  runTool,
  runScanBatch,
  runScanBatchAsync,
  getSupportedTools,
  getInstalledTools,
  isToolInstalled,
};




################################################################################
## FILE 64: subscriptionService.js
## Path: server/src/services/subscriptionService.js
################################################################################

const User = require('../models/User');

// Plan configurations
const PLANS = {
  free: {
    name: 'Free',
    price: 0,
    scansPerMonth: 10,
    codeReviewsPerDay: 3,
    toolsAvailable: ['nikto', 'gobuster'],
    features: ['Basic scanning', 'Scan history', 'PDF export']
  },
  pro: {
    name: 'Pro',
    price: 9.99,
    scansPerMonth: 100,
    codeReviewsPerDay: 20,
    toolsAvailable: ['nikto', 'gobuster', 'nuclei', 'sqlmap'],
    features: ['All Free features', 'Advanced scanning tools', 'Priority support', 'AI Code Review']
  },
  vip: {
    name: 'VIP',
    price: 29.99,
    scansPerMonth: -1, // Unlimited
    codeReviewsPerDay: -1, // Unlimited
    toolsAvailable: ['nikto', 'gobuster', 'nuclei', 'sqlmap', 'xsstrike', 'wpscan'],
    features: ['All Pro features', 'Unlimited scans', 'Unlimited code reviews', 'Auto-remediation suggestions', 'API access']
  }
};

/**
 * Get plan details
 */
const getPlanDetails = (planName) => {
  return PLANS[planName] || PLANS.free;
};

/**
 * Get all available plans
 */
const getAllPlans = () => {
  return Object.entries(PLANS).map(([key, plan]) => ({
    id: key,
    ...plan
  }));
};

/**
 * Check if user can perform a scan based on their plan limits
 */
const canPerformScan = async (userId) => {
  const user = await User.findById(userId);
  if (!user) throw new Error('User not found');

  const plan = getPlanDetails(user.subscription?.plan || 'free');
  
  // Check if subscription is active (for paid plans)
  if (user.subscription?.plan !== 'free' && user.subscription?.status !== 'active') {
    return { allowed: false, reason: 'Subscription is not active' };
  }

  // Unlimited scans
  if (plan.scansPerMonth === -1) {
    return { allowed: true };
  }

  // Reset monthly count if needed
  const now = new Date();
  if (user.usage?.scansResetDate && now > user.usage.scansResetDate) {
    await User.findByIdAndUpdate(userId, {
      'usage.scansThisMonth': 0,
      'usage.scansResetDate': new Date(now.getFullYear(), now.getMonth() + 1, 1)
    });
    return { allowed: true };
  }

  const scansUsed = user.usage?.scansThisMonth || 0;
  if (scansUsed >= plan.scansPerMonth) {
    return { 
      allowed: false, 
      reason: `Monthly scan limit reached (${scansUsed}/${plan.scansPerMonth}). Upgrade your plan for more scans.`,
      limit: plan.scansPerMonth,
      used: scansUsed
    };
  }

  return { allowed: true, remaining: plan.scansPerMonth - scansUsed };
};

/**
 * Check if user can perform code review based on their plan limits
 */
const canPerformCodeReview = async (userId) => {
  const user = await User.findById(userId);
  if (!user) throw new Error('User not found');

  const plan = getPlanDetails(user.subscription?.plan || 'free');
  
  // Check if subscription is active (for paid plans)
  if (user.subscription?.plan !== 'free' && user.subscription?.status !== 'active') {
    return { allowed: false, reason: 'Subscription is not active' };
  }

  // Unlimited code reviews
  if (plan.codeReviewsPerDay === -1) {
    return { allowed: true };
  }

  // Reset daily count if needed
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  
  if (user.usage?.codeReviewsResetDate && now > user.usage.codeReviewsResetDate) {
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    
    await User.findByIdAndUpdate(userId, {
      'usage.codeReviewsToday': 0,
      'usage.codeReviewsResetDate': tomorrow
    });
    return { allowed: true };
  }

  const reviewsUsed = user.usage?.codeReviewsToday || 0;
  if (reviewsUsed >= plan.codeReviewsPerDay) {
    return { 
      allowed: false, 
      reason: `Daily code review limit reached (${reviewsUsed}/${plan.codeReviewsPerDay}). Upgrade your plan or try again tomorrow.`,
      limit: plan.codeReviewsPerDay,
      used: reviewsUsed
    };
  }

  return { allowed: true, remaining: plan.codeReviewsPerDay - reviewsUsed };
};

/**
 * Check if a tool is available for user's plan
 */
const isToolAvailable = async (userId, toolName) => {
  const user = await User.findById(userId);
  if (!user) throw new Error('User not found');

  const plan = getPlanDetails(user.subscription?.plan || 'free');
  return plan.toolsAvailable.includes(toolName.toLowerCase());
};

/**
 * Check if auto-remediation is available for user
 */
const hasAutoRemediation = async (userId) => {
  const user = await User.findById(userId);
  if (!user) return false;
  
  return user.subscription?.plan === 'vip' && user.subscription?.status === 'active';
};

/**
 * Increment scan count for user
 */
const incrementScanCount = async (userId) => {
  const now = new Date();
  const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
  
  await User.findByIdAndUpdate(userId, {
    $inc: { 'usage.scansThisMonth': 1 },
    $setOnInsert: { 'usage.scansResetDate': nextMonth }
  }, { upsert: true });
};

/**
 * Increment code review count for user
 */
const incrementCodeReviewCount = async (userId) => {
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const tomorrow = new Date(today);
  tomorrow.setDate(tomorrow.getDate() + 1);
  
  await User.findByIdAndUpdate(userId, {
    $inc: { 'usage.codeReviewsToday': 1 },
    $setOnInsert: { 'usage.codeReviewsResetDate': tomorrow }
  }, { upsert: true });
};

/**
 * Upgrade user's subscription
 */
const upgradeSubscription = async (userId, newPlan, paymentDetails = {}) => {
  if (!PLANS[newPlan]) {
    throw new Error('Invalid plan');
  }

  const now = new Date();
  const endDate = new Date(now);
  endDate.setMonth(endDate.getMonth() + 1);

  const updateData = {
    'subscription.plan': newPlan,
    'subscription.status': newPlan === 'free' ? 'active' : 'active', // Would be 'pending' until payment confirmed
    'subscription.startDate': now,
    'subscription.endDate': newPlan === 'free' ? null : endDate,
    'subscription.autoRenew': paymentDetails.autoRenew || false
  };

  const user = await User.findByIdAndUpdate(userId, updateData, { new: true });
  
  return {
    success: true,
    plan: PLANS[newPlan],
    subscription: user.subscription
  };
};

/**
 * Cancel subscription (downgrade to free)
 */
const cancelSubscription = async (userId) => {
  const user = await User.findByIdAndUpdate(userId, {
    'subscription.status': 'cancelled',
    'subscription.autoRenew': false
  }, { new: true });

  return {
    success: true,
    message: 'Subscription cancelled. You will retain access until the end of your billing period.',
    endDate: user.subscription?.endDate
  };
};

/**
 * Get user's subscription status and usage
 */
const getSubscriptionStatus = async (userId) => {
  const user = await User.findById(userId);
  if (!user) throw new Error('User not found');

  const plan = getPlanDetails(user.subscription?.plan || 'free');
  const usage = user.usage || {};

  return {
    plan: {
      id: user.subscription?.plan || 'free',
      ...plan
    },
    status: user.subscription?.status || 'active',
    startDate: user.subscription?.startDate,
    endDate: user.subscription?.endDate,
    autoRenew: user.subscription?.autoRenew || false,
    usage: {
      scansThisMonth: usage.scansThisMonth || 0,
      scansLimit: plan.scansPerMonth,
      scansRemaining: plan.scansPerMonth === -1 ? 'Unlimited' : Math.max(0, plan.scansPerMonth - (usage.scansThisMonth || 0)),
      codeReviewsToday: usage.codeReviewsToday || 0,
      codeReviewsLimit: plan.codeReviewsPerDay,
      codeReviewsRemaining: plan.codeReviewsPerDay === -1 ? 'Unlimited' : Math.max(0, plan.codeReviewsPerDay - (usage.codeReviewsToday || 0))
    }
  };
};

module.exports = {
  PLANS,
  getPlanDetails,
  getAllPlans,
  canPerformScan,
  canPerformCodeReview,
  isToolAvailable,
  hasAutoRemediation,
  incrementScanCount,
  incrementCodeReviewCount,
  upgradeSubscription,
  cancelSubscription,
  getSubscriptionStatus
};



